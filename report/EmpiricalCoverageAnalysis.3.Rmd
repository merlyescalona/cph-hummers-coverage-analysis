---
title: "Analysis of coverage in capture experiments"
author: "Merly Escalona <merlyescalona@uvigo.es>"
output:
  html_document:
    theme: cosmo
    toc: yes
  html_notebook:
    theme: cosmo
---

```{R libraries, echo=F}
packages<-c("ape","geiger","apTreeshape","ggplot2","gplots","RColorBrewer","knitr","phangorn","futile.logger","phytools","shiny")
for(pkg in packages ){
  suppressMessages(library(pkg,character.only=TRUE,quietly=TRUE))
}
# Helpful functions: http://stackoverflow.com/a/6463946
roundUp <- function(x) 10^ceiling(log10(x))
roundUpNice <- function(x, nice=c(1,2,4,5,6,8,10)) {
    if(length(x) != 1) stop("'x' must be of length 1")
    10^floor(log10(x)) * nice[[which(x <= 10^floor(log10(x)) * nice)[[1]]]]
}
```

# Introduction

In order to integrate a new feature of on/off target levels of coverage in NGSphy, I needed to understand coverage variation that  one could find in a capture experiment. Goals are basically:

  1. Understand the coverage variation within samples and loci to be able to model it for both NGSphy parameterization and furthers simulations.
  2. Find out whether there is a correlation between the coverage and the phylogenetic distance to the reference species, used for the probe generation.
  Expecting that the closer the sample is to the reference the higher the coverage obtained Âºis.

# Data

Data used comes from  Rute's Hummingbird project. Most of the information reported here about the samples and targets was extracted from the paper.

- **Samples**: species were chosen so that all the nine major Trochiliform clades reported by Bleiweiss et al. [ [1] ](#Bleiweiss) and McGuire et al. [ [2] ](#McGuire) and many of the characteristic subclades illustrated by McGuire et al. [[2]](#McGuire) were represented.
    - 32 species - the National Museum of Natural History, Smithsonian Institution
    - 14 species - the Louisiana State University Museum of Natural Sciences

- **Target regions**: probes were selected from one-to-one orthologs between chicken (*Gallus gallus*) and zebra finch (*Taeniopygia guttata*) as annotated in ENSEMBL
version 66 annotation resulting in a final set:
    - 166.322 probes
    - corresponding to 2950 genes
    - summing up to approximately 20 Mb (for an approximately 7 Mb of total captured sequence).
    - final number of genes used is 2750, which are those left after removing genes with missing data.

- The **datasets** I'm using `BAM` files corresponding to the mappings of the targeted-sequencing to 2 references.
    - 46 files, corresponding to the samples mapped to an ingroup *Calypte anna* (from now on called `map2Anna`).
    - 48 files (46 samples + Aan + Swift), corresponding to the samples an outgroup  *Chaetura pelagica* (from now on called `map2Swift`).


## Processing and storage

Workspace `triploid` (UVigo):

  - Original data from Dataset 1, is stored in: `triploid.uvigo.es`
  - Under the user folder: `/home/merly/ research/cph-bam-coverage`

Workspace `randy` (KU):

  - Original data from Dataset 1 and 2, is stored in: `randy.popgen.dk`
  - Under the user folder:
      - `/home/merly/anna`
      - `/home/merly/swift`


# Targeted regions

Targeted regions are exons, retrieved a posteriori,  due to the fact that the original probes for this project were lost during a flood.

- **`Ingroup reference`**: Original target files given was a GFF file: `Calypte_anna.gene.CDS.2750.gff` [1.6M]. This file was converted into a BED file, keeping only chromosome (scaffold), start and end position of the targets.
    1. Filtering regions with size 0

- **`Outgroup reference:`**: For this one, I received 2 files. One that had the known one-to-one ortholog relation  between the genes from Anna and Swift (`48birds_ortholog.list.chi.anna.cpe.hum.finch` [656K]).
The second, is a GFF file, which contains the exons from Swift (`Chaetura_pelagica.CDS.gff`[8.5M]). I had to get the targeted regions from the GFF files, taking into account that I needed the genes matching to Anna, and also I needed those genes that were actually used in the Anna's targets  (`Calypte_anna.gene.CDS.2750.gff`):
    1. Keep the gene that matched both Anna and Swift species within this file `48birds_ortholog.list.chi.anna.cpe.hum.finch`.
    2. Filter out those where there was no match  (Gene in Anna == "-" or Gene in Swift == "-")
    3. Filtering regions with size 0
    4. Check that all the targets in `Chaetura_pelagica.CDS.gff` where codon regions (`CDS`).
    5. Match the genes obtained in (4), to the data in `Calypte_anna.gene.CDS.2750.gff` so I'll have the same covered genes.
    6. Match the resulting genes from  (5) to `Chaetura_pelagica.CDS.gff` and keep those regions matching both Anna and Swift.

Finally, datasets will be filter to match gene number.

```{R,echo=F}
WD="/media/merly/Baymax/research/cph-visit/coverage-analysis/files/"
# WD="/home/merly/files/"
```
```{R}
birds48filename=paste0(WD,"48birds_ortholog.list.chi.anna.cpe.hum.finch")
swiftgff=paste0(WD,"Chaetura_pelagica.CDS.gff")
annagff=paste0(WD,"Calypte_anna.gene.CDS.2750.gff")
birds=read.table(birds48filename, header=T,
    colClasses=c("character","numeric","character","character",
      "character","character","character"))
swift=read.table(swiftgff,
    colClasses=c("character","character","character","numeric",
      "numeric","character","character","character","character"))
anna=read.table(annagff,
    colClasses=c("character","character","character","numeric",
      "numeric","character","character","character","character"))

birds.2=birds[birds$anna!="-",]
birds.3=birds.2[birds.2$swift!="-",]
birds.4=unique(birds.3)
birds.5=birds.4[,c("anna","swift")]
birds.5$swift=paste0("Parent=",birds.5$swift,";")
birds.5$anna=paste0("Parent=Aan_", birds.5$anna,";")
annaGenes=unique(anna$V9[birds.5$anna %in% anna$V9])
birds.6=birds.5[birds.5$anna %in% annaGenes, ]
swiftGenes=birds.6$swift

swift.2=swift[swift$V3=="CDS",]
swift.3=swift.2[swift.2$V9 %in% birds.6$swift,]
swift.3$size=swift.3$V5-swift.3$V4
swift.4=swift.3[swift.3$size>0,]
anna.2=anna[(anna$V5-anna$V4)>0,]
swift.4=swift.4[,1:(ncol(swift.4)-1)]
anna.3=anna.2[anna.2$V9 %in% unique(birds.6$anna),]
anna.3$targetname=paste0( anna.3$V1,
  rep("-", nrow(anna.3)),
  anna.3$V4,
  rep("-", nrow(anna.3)),
  anna.3$V5)
swift.4$targetname=paste0( swift.4$V1,
  rep("-", nrow(swift.4)),
  swift.4$V4,
  rep("-", nrow(swift.4)),
  swift.4$V5)

```

### Description of the targeted regions

This is a quantitative summary description of the resulting target files. The difference  between number of genes, and subsequently in number of targets and covered genome,  in both Anna and Swift, is not precisely alarming. The experiment was done using known ortholog genes, which not necessarily match in number of exons (targets) or their size. There are  two (`2`) Anna datasets, the original and the reduced (1,469 genes) and the Swift dataset.

```{R data.load, echo=F}
nGenesSwift=length(unique(swift.4$V9))
nGenesAnna=length(unique(anna.2$V9))
# ------------------------------------------------------------------------------
targetsBedFile=paste0(WD,"targets.anna.2.bed")
targets=read.table(targetsBedFile, stringsAsFactors=F)
targets$V4=targets$V3-targets$V2
colnames(targets)=c("Scaffold","Start","End","Size")
rownames(targets)=paste0( targets$Scaffold,
  rep("-", nrow(targets)),
  targets$Start,
  rep("-", nrow(targets)),
  targets$End)
numTargets=nrow(targets)
totalBases=sum(targets$Size)
scaffoldsSplit=split(targets, targets$Scaffold)
totalScaffolds=length(scaffoldsSplit)
totalTargetPerScaffold=sapply(scaffoldsSplit,nrow)
# ------------------------------------------------------------------------------
# Reduced
reducedTargets=read.table(paste0(WD,"targets.anna.3.bed"), stringsAsFactors=F)
reducedTargets$V4=reducedTargets$V3-reducedTargets$V2
colnames(reducedTargets)=c("Scaffold","Start","End","Size")
rownames(reducedTargets)=paste0(reducedTargets$Scaffold,
  rep("-", nrow(reducedTargets)),
  reducedTargets$Start,
  rep("-", nrow(reducedTargets)),
  reducedTargets$End)
numReducedTargets=nrow(reducedTargets)
totalBasesReduced=sum(reducedTargets$Size)
scaffoldsReduced=scaffoldsSplit[names(scaffoldsSplit) %in% unique(anna.3$V1)]
totalScaffoldsReduced=length(scaffoldsReduced)
# ------------------------------------------------------------------------------
targetSwiftBedFile=paste0(WD,"targets.swift.2.bed")
targetsSwift=read.table(targetSwiftBedFile, stringsAsFactors=F)
targetsSwift$V4=targetsSwift$V3-targetsSwift$V2
colnames(targetsSwift)=c("Scaffold","Start","End","Size")
rownames(targetsSwift)=paste0(targetsSwift$Scaffold,
  rep("-", nrow(targetsSwift)),
  targetsSwift$Start,
  rep("-", nrow(targetsSwift)),
  targetsSwift$End)
numTargetsSwift=nrow(targetsSwift)
totalBasesSwift=sum(targetsSwift$Size)
scaffoldsSplitSwift=split(targetsSwift, targetsSwift$Scaffold)
totalScaffoldsSwift=length(scaffoldsSplitSwift)
totalTargetPerScaffoldSwift=sapply(scaffoldsSplitSwift,nrow)

# -----------------------------------------------------------------------------------------------------------------------------------------------
descriptionTargets=data.frame(
  NumTargets=prettyNum(c(numTargets,numReducedTargets, numTargetsSwift), big.mark = ","),
  SizeOfTargetedGenome=prettyNum(c(totalBases, totalBasesReduced,totalBasesSwift), big.mark = ","),
  nGenes=prettyNum(c(nGenesAnna,length(unique(anna.3$V9)),nGenesSwift),big.mark = ","),
  TotalScaffolds=prettyNum(c(totalScaffolds,totalScaffoldsReduced, totalScaffoldsSwift), big.mark = ",")
)
rownames(descriptionTargets)=c("Anna - Original","Anna - Reduced","Swift")
colnames(descriptionTargets)=c(
  "Number of targets",
  "Size of targeted genome (bp)",
  "Number of genes",
  "Total of scaffolds"
)
kable(descriptionTargets,format="markdown")
```

## Number of targeted regions per gene

```{R, echo=F, fig.width=12}
agSplit=split(anna.2, anna.2$V9)
sgSplit=split(swift.4, swift.4$V9)
totalTargetPerGenesA=sapply(agSplit,nrow)
totalTargetPerGenesS=sapply(sgSplit,nrow)
maxX=max(length(totalTargetPerGenesA), length(totalTargetPerGenesA))
maxY=roundUpNice(max(unlist(totalTargetPerGenesS), unlist(totalTargetPerGenesS)))
layout(matrix(c(1,2),1,2))
plot(totalTargetPerGenesA,pch=16, col="gray77", xlim=c(0,maxX), ylim=c(0,maxY),axes=F, xlab="Genes", ylab="Number of targeted regions", main="Anna")
points(totalTargetPerGenesA[unique(anna.3$V9)],pch=16, col="darkred", xlim=c(0,maxX), ylim=c(0,maxY))
axis(2, las=2); axis(1)
legend("topright",col=c("gray77","darkred"), pch=20, legend = c("Original dataset", "Reduced (Matched genes)"))
plot(totalTargetPerGenesS,pch=16, col="darkblue", xlim=c(0,maxX), ylim=c(0,maxY),axes=F, xlab="Genes", ylab="",main="Swift")
axis(2, las=2); axis(1)
```

## Number of targeted regions per scaffold

- Scaffolds:  where genes are located.

```{R echo=F, fig.width=12}
maxX=max(length(totalTargetPerScaffold), length(totalTargetPerScaffoldSwift))
maxY=roundUpNice(max(unlist(totalTargetPerScaffold), unlist(totalTargetPerScaffoldSwift)))

layout(matrix(c(1,2),1,2))
plot(totalTargetPerScaffold,pch=16, col="gray77", xlim=c(0,maxX), ylim=c(0,maxY),axes=F, xlab="Scaffolds", ylab="Number of targeted regions", main="Anna")
points(totalTargetPerScaffold[unique(anna.3$V1)],
  pch=16, col="darkred", xlim=c(0,maxX), ylim=c(0,maxY))
axis(2); axis(1)
legend("topright",col=c("gray77","darkred"), pch=20, legend = c("Original dataset", "Reduced (Matched genes)"))
plot(totalTargetPerScaffoldSwift,pch=16, col="darkblue", xlim=c(0,maxX), ylim=c(0,maxY),axes=F, xlab="Scaffolds", ylab="Number of targeted regions",main="Swift")
axis(2); axis(1)
```


## Gene size distribution

```{R, echo=F, fig.width=15}
genesAnna=data.frame(genes=as.character(unique(anna.2$V9)))
genesSplit=split(anna.2, anna.2$V9)
genesAnna$Size=sapply(genesSplit,function(x){sum(x$V5-x$V4)})
genesAnnaReduced=data.frame(genes=as.character(unique(anna.3$V9)),
                            Size=genesAnna$Size[genesAnna$genes %in% unique(anna.3$V9)])

genesSwift=data.frame(genes=as.character(unique(swift.4$V9)))
genesSplit=split(swift.4, swift.4$V9)
genesSwift$Size=sapply(genesSplit,function(x){sum(x$V5-x$V4)})
d1=density(genesAnna$Size)
d2=density(genesSwift$Size)
d3=density(genesAnnaReduced$Size)
plot(d1,type="l",col="gray77", lwd=3, main="Gene size distribution", xlab="Size (bp)")
points(d3,type="l", col="darkred", lwd=3)
points(d2,type="l", col="darkblue", lwd=3)
legend("topright", col=c("gray77","darkred","darkblue"),legend=c("Anna - Original","Anna - Reduced","Swift"),  lwd=3)

summaryDistroSize=rbind(
  t(summary(genesAnna$Size)),
  t(summary(genesAnnaReduced$Size)),
  t(summary(genesSwift$Size))
  )
rownames(summaryDistroSize)=c("Anna - Original","Anna - Reduced","Swift")
summaryDistroSize[1:3,]=prettyNum(summaryDistroSize[1:3,], big.mark=",")
kable(summaryDistroSize, format="markdown")
```

## Targeted regions size distribution

```{R echo=F, fig.width=12}
d1=density(targets$Size)
d2=density(targetsSwift$Size)
d3=density(targets$Size[targets$Scaffold %in% unique(anna.3$V1)])
plot(d1,type="l",col="gray77", lwd=3, main="Target size distribution", xlab="Size (bp)")
points(d3,type="l", col="darkred", lwd=3)
points(d2,type="l", col="darkblue", lwd=3)
legend("topright", col=c("gray77","darkred","darkblue"),legend=c("Anna - Original","Anna - Reduced","Swift"),  lwd=3)
summaryDistroSize=rbind(
  t(summary(targets$Size)),
  t(summary(targets$Size[targets$Scaffold %in% unique(anna.3$V1)])),
  t(summary(targetsSwift$Size))
  )
rownames(summaryDistroSize)=c("Anna - Original","Anna - Reduced","Swift")
summaryDistroSize[1:3,]=prettyNum(summaryDistroSize[1:3,], big.mark=",")
kable(summaryDistroSize, format="markdown")
```

- These target size distribution are pretty much alike, but, there are some targeted regions up to ~5Kb. A question that can appear is whether these regions were expected (in terms of size).
The idea with this experiment was to capture whole genes, and for this reason, theses sizes are not unexpected. Depth of coverage, which is what is being analyze here, depends more on
probe feature decisions like size and density of the tiling.


# On-target coverage

<div class="panel panel-info">
<div class="panel-heading">
<h3 class="panel-title">**NOTE**</h3>
</div>
<div class="panel-body">
Target datasets used from now on will contain the same number of genes (1,469).
</div>
</div>

I obtained the coverage of the targeted regions using **`bedtools`**[[9]](#bedtools) (v. 2.22.0), module `coverage`. With this, and the option `-hist` I can report a histogram of coverage for each
feature in A as well as a summary histogram for `_all_` features in A. Output (tab delimited) after each feature in A (from [`bedtools` documentation](http://bedtools.readthedocs.io/en/latest/content/tools/coverage.html)))

1. depth
2. `#` bases at depth
3. size of A
4. % of A at depth


```{bash, eval=F}
for bamfile in $(find $HOME/anna/originals -name "*.bam"); do
  tag=$(echo $(basename $bamfile) | tr "_" " " | awk '{print $1}')
  nohup bedtools coverage -hist -abam $bamfile -b "Calypte_anna.gene.CDS.2750.3.gff" | gzip > $HOME/anna/bedtools/cov/${tag}.cov.gz &
done
for bamfile in $(find $HOME/swift/originals -name "*.bam"); do
  tag=$(echo $(basename $bamfile) | tr "_" " " | awk '{print $1}')
  nohup bedtools coverage -hist -abam $bamfile -b  "Chaetura_pelagica.CDS.2.gff" | gzip > $HOME/swift/bedtools/cov/${tag}.cov.gz &
done
```

And so, I filtered the output to keep the coverage per region and the summary histogram separated.

```{bash, eval=F}
# (i.e)
for tag in $(cat $HOME/anna/files/samples.txt  ); do
  nohup zcat  $HOME/anna/bedtools/cov/H09.cov.gz | grep -v ^all | gzip >  $HOME/anna/bedtools/nohist/$tag.nohist.gz &
  nohup zcat  $HOME/anna/bedtools/cov/H09.cov.gz | grep  ^all | gzip  >    $HOME/anna/bedtools/hist/$tag.hist.gz &
done
for tag in $(cat $HOME/swift/files/samples.txt | tail -n+2 | head -46 ); do
  nohup zcat  $HOME/swift/bedtools/cov/H09.cov.gz | grep -v ^all | gzip >  $HOME/swift/bedtools/nohist/$tag.nohist.gz &
  nohup zcat  $HOME/swift/bedtools/cov/H09.cov.gz | grep  ^all | gzip  >    $HOME/swift/bedtools/hist/$tag.hist.gz &
done

```

## Breadth vs. depth

With the information extracted from the `bedtools coverage -hist`, we can see the relation between the breadth of coverage obtained and the depth per sample.

| Map2 - target | Coverage per target overview |
|---------------|------------------------------|
| **map2Anna**  |  ![](/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/img2/2.breadth.vs.coverage.1.all.png) |
| **map2Swift**  |  ![](/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/img2/2.breadth.vs.coverage.1.all.png) |


**Zoom**: 0x-100x.

| **map2Anna** | **map2Swift** |
|-------------|---------------|
| ![](/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/img2/2.breadth.vs.coverage.2.zoom.500.png) | ![](/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/img2/2.breadth.vs.coverage.2.zoom.500.png)  |


## Depth of coverage

From the `bedtools coverage` output I was able to extract the depth of coverage per target, gene and sample.
I generated 2  matrices:

- Target depth: dimensions -- number of targets $\times$ number of samples
- Gene depth: dimensions -- number of genes  $\times$  number of samples

Each cell of the matrix correspond to the sum of the number of times each base was covered within the target or the gene.
Then, coverage was calculated as the mean value of all the depth of coverage of all the samples for a specific target/gene divided by the size of the corresponding target/gene.

For the depth of coverage for the samples, I summed the coverage of all targets and divided it by the total amount of bases that were targeted.

**Note:** Outliers presented below were calculated using the following:

```{R, eval=F}
qnt <- quantile(data, probs=c(.25, .75))
H <- 1.5 * IQR(data)
y <- data
y[data < (qnt[1] - H)] <- "Outlier"
y[data > (qnt[2] + H)] <- "Outlier"
```

### Coverage per sample

#### Depth per sample

```{R, echo=F, fig.width=12,fig.height=8}
coveragePerSampleAnna=unlist(read.table("/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/files2/coverage.per.sample.txt", stringsAsFactors=F, colClasses=c("character","numeric")))
coveragePerSampleSwift=unlist(read.table("/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/files2/coverage.per.sample.txt", stringsAsFactors=F, colClasses=c("character","numeric")))
sampleNamesAnna=unlist(read.table("/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/files/samples.txt", stringsAsFactors = F))
sampleNamesSwift=unlist(read.table("/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/files/samples.txt", stringsAsFactors = F))
names(coveragePerSampleAnna)=sampleNamesAnna
names(coveragePerSampleSwift)=sampleNamesSwift
################################################################################
# ANNA
qntAnna <- quantile(coveragePerSampleAnna, probs=c(.25, .75))
HAnna <- 1.5 * IQR(coveragePerSampleAnna)
y <- rep("black",length(coveragePerSampleAnna))
y[coveragePerSampleAnna < (qntAnna[1] - HAnna)] <- "red"
y[coveragePerSampleAnna > (qntAnna[2] + HAnna)] <- "red"
# samples close to ingroup ref: h1, h5,22,30
closeToRefIngroup=c("H1","H5","H22","H30")
closeToRefIngroupIndices=c(which(sampleNamesAnna==closeToRefIngroup[1]),which(sampleNamesAnna==closeToRefIngroup[2]),
                           which(sampleNamesAnna==closeToRefIngroup[3]),which(sampleNamesAnna==closeToRefIngroup[4]))
pchList=rep(20, length(sampleNamesAnna))
pchList[closeToRefIngroupIndices]=17
#-------------------------------------------------------------------------------
maxY=roundUpNice(max(coveragePerSampleAnna,coveragePerSampleSwift))
layout(matrix(c(1,2),1,2))
plot(1:length(sampleNamesAnna),coveragePerSampleAnna,axes=F, ylim=c(0,maxY),
  xlab="Samples",ylab="Depth of coverage", pch=pchList, col=y, main="Map2Aan")

abline(h=qntAnna[1], col="darkblue", lty="dashed", lwd=2)
abline(h=qntAnna[2], col="darkblue", lty="dashed", lwd=2)
abline(h=median(coveragePerSampleAnna), col="darkblue", lwd=2)
axis(2,at=seq(0,300, 25),las=2,cex.axis=0.6)
axis(1, at=1:length(sampleNamesAnna), las=2,labels=sampleNamesAnna,cex.axis=0.8)
text(labels = "median",x = 48,y = median(coveragePerSampleAnna)+5, cex=0.5)
text(labels = "Q.25",x = 48,y = qntAnna[1]+5, cex=0.5)
text(labels = "Q.75",x = 48,y = qntAnna[2]+5, cex=0.5)
################################################################################
# swift
qntSwift <- quantile(coveragePerSampleSwift, probs=c(.25, .75))
HSwift <- 1.5 * IQR(coveragePerSampleSwift)
y <- rep("black",length(coveragePerSampleSwift))
y[coveragePerSampleSwift < (qntSwift[1] - HSwift)] <- "red"
y[coveragePerSampleSwift > (qntSwift[2] + HSwift)] <- "red"
closeToRefIngroupIndices=c(which(sampleNamesSwift==closeToRefIngroup[1]),which(sampleNamesSwift==closeToRefIngroup[2]),
                           which(sampleNamesSwift==closeToRefIngroup[3]),which(sampleNamesSwift==closeToRefIngroup[4]))
pchList=rep(20, length(sampleNamesSwift))
pchList[closeToRefIngroupIndices]=17
#-------------------------------------------------------------------------------
plot(1:length(sampleNamesSwift),coveragePerSampleSwift,axes=F,ylim=c(0,maxY),
  xlab="Samples",ylab="", pch=pchList, col=y, main="Map2Swift")
abline(h=qntSwift[1], col="darkblue", lty="dashed", lwd=2)
abline(h=qntSwift[2], col="darkblue", lty="dashed", lwd=2)
abline(h=median(coveragePerSampleSwift), col="darkblue", lwd=2)
axis(2,at=seq(0,300, 25),las=2,cex.axis=0.6)
axis(1, at=1:length(sampleNamesSwift), las=2,labels=sampleNamesSwift,cex.axis=0.8)
text(labels = "median",x = 48,y = median(coveragePerSampleSwift)+5, cex=0.5)
text(labels = "Q.25",x = 48,y = qntSwift[1]+5, cex=0.5)
text(labels = "Q.75",x = 48,y = qntSwift[2]+5, cex=0.5)

legend("topright", legend = c("Outlier",  "Outlier close to ingroup ref", "Not-outlier","Not-outlier close to ingroup ref"),
       col=c(rep("red",2),rep("black",2)),
       pch=c(20,17,20,17))
summaryCoveragePerSample=rbind(
  t(summary(coveragePerSampleAnna)),
  t(summary(coveragePerSampleSwift))
)
rownames(summaryCoveragePerSample)=c("map2Anna","map2Swift")
summaryCoveragePerSample[1:2,]=prettyNum(summaryCoveragePerSample[1:2,], big.mark=",")
kable(summaryCoveragePerSample, format="markdown")
```

#### Coverage distribution per sample

```{R, echo=F, fig.width=12, fig.height=8}
coveragePerSampleAnnaNO=coveragePerSampleAnna
coveragePerSampleAnnaNO[ coveragePerSampleAnna < (qntAnna[1] - HAnna)]=NA
coveragePerSampleAnnaNO[coveragePerSampleAnna > (qntAnna[2] + HAnna)]=NA
coveragePerSampleAnnaNO=coveragePerSampleAnnaNO[!is.na(coveragePerSampleAnnaNO)]

coveragePerSampleSwiftNO=coveragePerSampleSwift
coveragePerSampleSwiftNO[ coveragePerSampleSwift < (qntSwift[1] - HSwift)]=NA
coveragePerSampleSwiftNO[coveragePerSampleSwift > (qntSwift[2] + HSwift)]=NA
coveragePerSampleSwiftNO=coveragePerSampleSwiftNO[!is.na(coveragePerSampleSwiftNO)]

d1Anna=density(coveragePerSampleAnna)
d1Swift=density(coveragePerSampleSwift)
maxY1=roundUpNice(max(d1Anna$y,d1Swift$y))

d2Anna=density(coveragePerSampleAnnaNO)
d2Swift=density(coveragePerSampleSwiftNO)
maxY2=roundUpNice(max(d2Anna$y,d2Swift$y))

layout(matrix(c(1,2),1,2))
plot(d1Anna, type="l", col="darkred", lwd=2, ylim=c(0,maxY1), main="All samples", xlab="Depth of coverage")
points(d1Swift, type="l", col="darkblue", lwd=2)
abline(v=c(mean(coveragePerSampleAnna),mean(coveragePerSampleSwift)), col=c("darkred","darkblue"), lty="dashed",lwd=2)
legend("topright",legend=c("Map2Anna","Map2Anna - mean coverage","Map2Swift", "Map2Swift - mean coverage"),
  col=c("darkred","darkred","darkblue","darkblue"),lty=c("solid","dashed","solid","dashed"),lwd=2)

plot(d2Anna, type="l", col="darkred", lwd=2, ylim=c(0,maxY2), main="Without outliers", xlab="Depth of coverage")
points(d2Swift, type="l", col="darkblue", lwd=2)
abline(v=c(mean(coveragePerSampleAnnaNO),mean(coveragePerSampleSwiftNO)), col=c("darkred","darkblue"), lty="dashed",lwd=2)
legend("topright",legend=c("Map2Anna","Map2Anna - mean coverage","Map2Swift", "Map2Swift - mean coverage"),
  col=c("darkred","darkred","darkblue","darkblue"),lty=c("solid","dashed","solid","dashed"),lwd=2)

```


### Coverage per gene

```{R, echo=F, fig.width=12, fig.height=6}
coveragePerGeneAnna=unlist(read.table(
  "/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/files2/coverage.per.gene.txt",
  stringsAsFactors=F,
  colClasses=c("character","numeric")))
coveragePerGeneSwift=unlist(read.table(
  "/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/files2/coverage.per.gene.txt",
  stringsAsFactors=F,
  colClasses=c("character","numeric")))
names(coveragePerGeneAnna)=unique(anna.3$V9)
names(coveragePerGeneSwift)=unique(swift.4$V9)
################################################################################
# ANNA
qnt <- quantile(coveragePerGeneAnna, probs=c(.25, .75))
H <- 1.5 * IQR(coveragePerGeneAnna)
y <- rep("black",length(coveragePerGeneAnna))
y[coveragePerGeneAnna < (qnt[1] - H)] <- "red"
y[coveragePerGeneAnna > (qnt[2] + H)] <- "red"
#-------------------------------------------------------------------------------
maxY=max(coveragePerGeneAnna,coveragePerGeneSwift)
layout(matrix(c(1,2),1,2))
plot(coveragePerGeneAnna,axes=F, ylim=c(0,maxY),
  xlab="Genes",ylab="Depth of coverage", pch=20, col=y, main="Map2Aan")
abline(h=qnt[1], col="darkblue", lty="dashed", lwd=2)
abline(h=qnt[2], col="darkblue", lty="dashed", lwd=2)
abline(h=mean(coveragePerGeneAnna), col="darkblue", lwd=2)
axis(2,las=2, cex.axis=0.6)
axis(1, at=seq(0,3000,250), labels=seq(0,3000,250),las=2,cex.axis=0.5)
################################################################################
# swift
qnt <- quantile(coveragePerGeneSwift, probs=c(.25, .75))
H <- 1.5 * IQR(coveragePerGeneSwift)
y <- rep("black",length(coveragePerGeneSwift))
y[coveragePerGeneSwift < (qnt[1] - H)] <- "red"
y[coveragePerGeneSwift > (qnt[2] + H)] <- "red"
#-------------------------------------------------------------------------------
plot(coveragePerGeneSwift,axes=F,ylim=c(0,maxY),
  xlab="Genes",ylab="Depth of coverage", pch=pchList, col=y, main="Map2Swift")
abline(h=qnt[1], col="darkblue", lty="dashed", lwd=2)
abline(h=qnt[2], col="darkblue", lty="dashed", lwd=2)
abline(h=mean(coveragePerGeneSwift), col="darkblue", lwd=2)
axis(2, las=2, cex.axis=0.6)
axis(1, at=seq(0,3000,250), labels=seq(0,3000,250),las=2,cex.axis=0.5)

legend("topright", legend = c("Outlier", "Not-outlier"),
       col=c("red","black"),
       pch=20)
summarycoveragePerGene=rbind(
  t(summary(coveragePerGeneAnna)),
  t(summary(coveragePerGeneSwift))
)
rownames(summarycoveragePerGene)=c("map2Anna","map2Swift")
summarycoveragePerGene[1:2,]=prettyNum(summarycoveragePerGene[1:2,], big.mark=",")
kable(summarycoveragePerGene, format="markdown")
```
<div class="panel panel-warning">
<div class="panel-heading">
<h3 class="panel-title">Outlier check - map2Anna</h3>
</div>
<div class="panel-body">
- Identification and removal of the outliers
```{R, echo=F}
# Get the outliers
qntAnna <- quantile(coveragePerGeneAnna, probs=c(.25, .75))
HAnna <- 1.5 * IQR(coveragePerGeneAnna)
y <- rep("black",length(coveragePerGeneAnna))
outliersAnna=coveragePerGeneAnna
outliersAnna[coveragePerGeneAnna < (qntAnna[1] - HAnna)] <- -1
outliersAnna[coveragePerGeneAnna > (qntAnna[2] + HAnna)] <- -1
outliersAnna[outliersAnna>=0]=0
outliersAnna[outliersAnna<0]=1
numOutliersAnna=sum(outliersAnna)
indexOutliers=which(outliersAnna>0)
geneAnnaOutliers=genesAnna[indexOutliers,]
colnames(geneAnnaOutliers)=c("Gene","Size")

qntSwift <- quantile(coveragePerGeneSwift, probs=c(.25, .75))
HSwift <- 1.5 * IQR(coveragePerGeneSwift)
y <- rep("black",length(coveragePerGeneSwift))
outliersSwift=coveragePerGeneSwift
outliersSwift[coveragePerGeneSwift < (qntSwift[1] - HSwift)] <- -1
outliersSwift[coveragePerGeneSwift > (qntSwift[2] + HSwift)] <- -1
outliersSwift[outliersSwift>=0]=0
outliersSwift[outliersSwift<0]=1
numOutliersSwift=sum(outliersSwift)
indexOutliers=which(outliersSwift>0)
geneSwiftOutliers=genesSwift[indexOutliers,]
colnames(geneSwiftOutliers)=c("Gene","Size")
geneAnnaOutliers$Gene=as.character(geneAnnaOutliers$Gene)
geneSwiftOutliers$Gene=as.character(geneSwiftOutliers$Gene)


```

- Number of outliers genes and coverage distribution

```{R, echo=F}
outliersDF=t(data.frame(
  anna=c(numOutliersAnna,summary(coveragePerGeneAnna[outliersAnna>0])),
  swift=c(numOutliersSwift, summary(coveragePerGeneSwift[outliersSwift>0]))
  ))
colnames(outliersDF)=c("Num. outliers", "Min.","1st. Qu.","Median","Mean","3rd. Qu.","Max.")
rownames(outliersDF)=c("map2Anna", "map2Swift")
kable(outliersDF, format="markdown")

```

- Outlier genes and corresponding size

```{R, echo=F}
geneOutliers=data.frame(cbind(geneAnnaOutliers,rbind(geneSwiftOutliers,c("",""),c("",""))))
colnames(geneOutliers)=c("map2Anna Gene","map2Anna Size","map2Swift Gene","map2Size Gene")
kable(geneOutliers, format="markdown",row.names = F)

annaOutInBirds=birds.6[birds.6$anna %in% geneAnnaOutliers$Gene, ]
intersectedGenes=intersect(geneSwiftOutliers$Gene, annaOutInBirds$swift)
```

- There is no correspondence of gene outliers across datasets:
    - knownOrthologs[geneOutliersInAnna] $\cap$ geneOutliersInSwift $=$ $\emptyset$

</div>
</div>

#### Depth of coverage distribution per gene after removing outliers

```{R, echo=F,fig.width=12, fig.height=8}
coveragePerGeneAnnaFiltered=coveragePerGeneAnna[! names(coveragePerGeneAnna) %in% geneAnnaOutliers$Gene]
coveragePerGeneSwiftFiltered=coveragePerGeneSwift[! names(coveragePerGeneSwift) %in% geneSwiftOutliers$Gene]
maxY=roundUpNice(max(coveragePerGeneAnnaFiltered,coveragePerGeneSwiftFiltered))
layout(matrix(c(1,2),1,2))
coveragePerGeneAnnaNO=coveragePerGeneAnna
coveragePerGeneAnnaNO[coveragePerGeneAnna < (qntAnna[1] - HAnna)]=NA
coveragePerGeneAnnaNO[coveragePerGeneAnna > (qntAnna[2] + HAnna)]=NA
coveragePerGeneAnnaNO=coveragePerGeneAnnaNO[!is.na(coveragePerGeneAnnaNO)]

coveragePerGeneSwiftNO=coveragePerGeneSwift
coveragePerGeneSwiftNO[coveragePerGeneSwift < (qntSwift[1] - HSwift)]=NA
coveragePerGeneSwiftNO[coveragePerGeneSwift > (qntSwift[2] + HSwift)]=NA
coveragePerGeneSwiftNO=coveragePerGeneSwiftNO[!is.na(coveragePerGeneSwiftNO)]

d1Anna=density(coveragePerGeneAnna)
d1Swift=density(coveragePerGeneSwift)
maxY1=roundUpNice(max(d1Anna$y,d1Swift$y))

d2Anna=density(coveragePerGeneAnnaNO)
d2Swift=density(coveragePerGeneSwiftNO)
maxY2=roundUpNice(max(d2Anna$y,d2Swift$y))

layout(matrix(c(1,2),1,2))
plot(d1Anna, type="l", col="darkred", lwd=2, ylim=c(0,maxY1), main="All samples", xlab="Depth of coverage")
points(d1Swift, type="l", col="darkblue", lwd=2)
abline(v=c(mean(coveragePerGeneAnna),mean(coveragePerGeneSwift)), col=c("darkred","darkblue"), lty="dashed",lwd=2)
legend("topright",legend=c("Map2Anna","Map2Anna - mean coverage","Map2Swift", "Map2Swift - mean coverage"),
  col=c("darkred","darkred","darkblue","darkblue"),lty=c("solid","dashed","solid","dashed"),lwd=2)

plot(d2Anna, type="l", col="darkred", lwd=2, ylim=c(0,maxY2), main="Without outliers", xlab="Depth of coverage")
points(d2Swift, type="l", col="darkblue", lwd=2)
abline(v=c(mean(coveragePerGeneAnnaNO),mean(coveragePerGeneSwiftNO)), col=c("darkred","darkblue"), lty="dashed",lwd=2)
legend("topright",legend=c("Map2Anna","Map2Anna - mean coverage","Map2Swift", "Map2Swift - mean coverage"),
  col=c("darkred","darkred","darkblue","darkblue"),lty=c("solid","dashed","solid","dashed"),lwd=2)


summarycoveragePerGene=rbind(
  t(summary(coveragePerGeneAnnaFiltered)),
  t(summary(coveragePerGeneSwiftFiltered))
)
rownames(summarycoveragePerGene)=c("map2Anna","map2Swift")
summarycoveragePerGene[1:2,]=prettyNum(summarycoveragePerGene[1:2,], big.mark=",")
kable(summarycoveragePerGene, format="markdown")
```

#### Gene size vs. depth of coverage
<!-- http://blog.yhat.com/posts/r-lm-summary.html -->
<!-- http://data.princeton.edu/R/linearModels.html -->
<!-- http://feliperego.github.io/blog/2015/10/23/Interpreting-Model-Output-In-R -->

I'm looking for a relation between gene size and depth of coverage. So I fit a
linear model to the data.

```{R, echo=F, fig.width=12,fig.height=6}
genesAnnaFiltered=genesAnna[which(genesAnna$genes %in% intersect(names(coveragePerGeneAnnaFiltered),genesAnna$genes)),]
genesSwiftFiltered=genesSwift[which(genesSwift$genes %in% intersect(names(coveragePerGeneSwiftFiltered),genesSwift$genes)),]
rownames(genesAnnaFiltered)=genesAnnaFiltered$genes
rownames(genesSwiftFiltered)=genesSwiftFiltered$genes
lmdAnna=lm(coveragePerGeneAnnaFiltered~genesAnnaFiltered$Size)
lmdSwift=lm(coveragePerGeneSwiftFiltered~genesSwiftFiltered$Size)

layout(matrix(c(1,2),1,2))
plot(genesAnnaFiltered$Size,coveragePerGeneAnnaFiltered, pch=20,
   xlab="Gene size",ylab="Depth of coverage",axes=F, main="map2Anna")
abline(lmdAnna, col="red",lwd=2)
axis(1);axis(2)
plot(genesSwiftFiltered$Size,coveragePerGeneSwiftFiltered, pch=20,
   xlab="Gene size",ylab="Depth of coverage",axes=F, main="map2Swift")
abline(lmdSwift, col="red",lwd=2)
axis(1);axis(2)
```


<ul class="nav nav-tabs">
<li class="active"><a href="#lmdanna" data-toggle="tab">map2Anna summary(lmd)</a></li>
<li><a href="#lmdswift" data-toggle="tab">map2Swift summary(lmd)</a></li>
</ul>
<div id="myTabContent" class="tab-content">
<div class="tab-pane fade active in" id="lmdanna">
<div class="panel panel-default">
<div class="panel-body">
```{R, echo=F, fig.width=10,fig.height=8}
summary(lmdAnna)
layout(matrix(c(1,2,3,4), 2,2, byrow=T))
plot(lmdAnna, pch=16)
```
</div>
</div>
</div>
<div class="tab-pane fade" id="lmdswift">
<div class="panel panel-default">
<div class="panel-body">
```{R, echo=F,fig.width=10,fig.height=8}
summary(lmdSwift)
layout(matrix(c(1,2,3,4), 2,2, byrow=T))
plot(lmdSwift, pch=16)
```
</div>
</div>
</div>
</div> <!-- end div -->


<div class="panel panel-danger">
<div class="panel-heading">
<h3 class="panel-title"> CHECK THIS OUT!</h3>
</div>
<div class="panel-body">
I need to understand how to interpret this
</div>
</div>



### Coverage per target

```{R, echo=F, fig.width=10, fig.height=6}
coveragePerTargetAnna=unlist(read.table("/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/files2/coverage.per.target.txt", stringsAsFactors=F, colClasses=c("character","numeric")))
coveragePerTargetSwift=unlist(read.table("/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/files2/coverage.per.target.txt", stringsAsFactors=F, colClasses=c("character","numeric")))
names(coveragePerTargetAnna)=rownames(reducedTargets)
names(coveragePerTargetSwift)=rownames(targetsSwift)

#filter by genes resulted out removing outliers
# genesAnnaFiltered
# genesSwiftFiltered

anna.4=anna.3[anna.3$V9 %in% genesAnnaFiltered$genes,]
swift.5=swift.4[swift.4$V9 %in% genesSwiftFiltered$genes,]
anna.4$targetname=paste0(
    anna.4$V1,rep("-",nrow(anna.4)),
    anna.4$V4,rep("-",nrow(anna.4)),
    anna.4$V5)
anna.4$Size=anna.4$V5-anna.4$V4
swift.5$targetname=paste0(
    swift.5$V1,rep("-",nrow(swift.5)),
    swift.5$V4,rep("-",nrow(swift.5)),
    swift.5$V5)
swift.5$Size=swift.5$V5-swift.5$V4

anna.4$Coverage=coveragePerTargetAnna[intersect(names(coveragePerTargetAnna),anna.4$targetname)]
swift.5$Coverage=coveragePerTargetSwift[intersect(names(coveragePerTargetSwift),swift.5$targetname)]


################################################################################
# ANNA
qnt <- quantile(anna.4$Coverage, probs=c(.25, .75))
H <- 1.5 * IQR(anna.4$Coverage)
y <- rep("black",length(anna.4$Coverage))
y[anna.4$Coverage < (qnt[1] - H)] <- "red"
y[anna.4$Coverage > (qnt[2] + H)] <- "red"
#-------------------------------------------------------------------------------
maxY=max(anna.4$Coverage,swift.5$Coverage)
layout(matrix(c(1,2),1,2))
plot(anna.4$Coverage,axes=F, ylim=c(0,maxY),
  xlab="Genes",ylab="Depth of coverage", pch=20, col=y, main="Map2Aan")
abline(h=qnt[1], col="red", lty="dashed", lwd=2)
abline(h=qnt[2], col="red", lty="dashed", lwd=2)
abline(h=median(anna.4$Coverage), col="red", lwd=2)
axis(2,las=2, cex.axis=0.6)
axis(1, las=2,cex.axis=0.5)
################################################################################
# swift
qnt <- quantile(swift.5$Coverage, probs=c(.25, .75))
H <- 1.5 * IQR(swift.5$Coverage)
y <- rep("black",length(swift.5$Coverage))
y[swift.5$Coverage < (qnt[1] - H)] <- "red"
y[swift.5$Coverage > (qnt[2] + H)] <- "red"
#-------------------------------------------------------------------------------
plot(swift.5$Coverage,axes=F,ylim=c(0,maxY),
  xlab="Genes",ylab="Depth of coverage", pch=20, col=y, main="Map2Swift")
abline(h=qnt[1], col="red", lty="dashed", lwd=2)
abline(h=qnt[2], col="red", lty="dashed", lwd=2)
abline(h=median(swift.5$Coverage), col="red", lwd=2)
axis(2, las=2, cex.axis=0.6)
axis(1, las=2,cex.axis=0.5)

legend("topright", legend = c("Outlier", "Not-outlier"),
       col=c("red","black"),
       pch=20)

summarycoveragePerTarget=rbind(
  t(summary(anna.4$Coverage)),
  t(summary(swift.5$Coverage))
)
rownames(summarycoveragePerTarget)=c("map2Anna","map2Swift")
summarycoveragePerTarget[1:2,]=prettyNum(summarycoveragePerTarget[1:2,], big.mark=",")
kable(summarycoveragePerTarget, format="markdown")
```

<div class="panel panel-warning">
<div class="panel-heading">
<h3 class="panel-title">Check</h3>
</div>
<div class="panel-body">
- Identification and removal of the outliers
```{R, echo=F}
qntAnna <- quantile(anna.4$Coverage, probs=c(.25, .75))
HAna <- 1.5 * IQR(anna.4$Coverage)
outliersTargetsAnna <- anna.4$Coverage
outliersTargetsAnna[anna.4$Coverage < (qntAnna[1] - HAna)] <- -1
outliersTargetsAnna[anna.4$Coverage > (qntAnna[2] + HAna)] <- -1
outliersTargetsAnna[outliersTargetsAnna>=0]=0
outliersTargetsAnna[outliersTargetsAnna<0]=1
numTargetsOutliersAnna=sum(outliersTargetsAnna)
indexOutliers=which(outliersTargetsAnna>0)
targetsOutliersAnna=data.frame(
  Target=anna.4$targetname[indexOutliers],
  Coverage=anna.4$Coverage[indexOutliers],
  Size=anna.4$Size[indexOutliers]
)
anna.5=anna.4[!(anna.4$targetname %in% targetsOutliersAnna$Target),]

# swift
qntSwift <- quantile(swift.5$Coverage, probs=c(.25, .75))
HSwift <- 1.5 * IQR(swift.5$Coverage)
outliersTargetsSwift <- swift.5$Coverage
outliersTargetsSwift[swift.5$Coverage < (qntSwift[1] - HSwift)] <- -1
outliersTargetsSwift[swift.5$Coverage > (qntSwift[2] + HSwift)] <- -1
outliersTargetsSwift[outliersTargetsSwift>=0]=0
outliersTargetsSwift[outliersTargetsSwift<0]=1
numTargetsOutliersSwift=sum(outliersTargetsSwift)
indexOutliers=which(outliersTargetsSwift>0)
targetsOutliersSwift=data.frame(
  Target=swift.5$targetname[indexOutliers],
  Coverage=swift.5$Coverage[indexOutliers],
  Size=swift.5$Size[indexOutliers]
)
swift.6=swift.5[!(swift.5$targetname %in% targetsOutliersSwift$Target),]
```

- Number of outliers targets and coverage distribution

```{R, echo=F}
outliersDF=t(data.frame(
  anna=c(numTargetsOutliersAnna,summary(anna.5$Coverage)),
  swift=c(numTargetsOutliersSwift, summary(swift.6$Coverage))
  ))
colnames(outliersDF)=c("Num. outliers", "Min.","1st. Qu.","Median","Mean","3rd. Qu.","Max.")
rownames(outliersDF)=c("map2Anna", "map2Swift")
outliersDF[1:2,]=prettyNum(outliersDF[1:2,],big.mark=",")
kable(outliersDF, format="markdown")
```
</div>
</div>



#### Depth of coverage distribution per target after removing coverage outliers

```{R, echo=F,fig.width=12, fig.height=8}
d1Anna=density(anna.4$Coverage)
d1Swift=density(swift.5$Coverage)
maxY1=roundUpNice(max(d1Anna$y,d1Swift$y))

d2Anna=density(anna.5$Coverage)
d2Swift=density(swift.6$Coverage)
maxY2=roundUpNice(max(d2Anna$y,d2Swift$y))

layout(matrix(c(1,2),1,2))
plot(d1Anna, type="l", col="darkred", lwd=2, ylim=c(0,maxY1), main="All samples", xlab="Depth of coverage")
points(d1Swift, type="l", col="darkblue", lwd=2)
abline(v=c(mean(anna.4$Coverage),mean(swift.5$Coverage)), col=c("darkred","darkblue"), lty="dashed",lwd=2)
legend("topright",legend=c("Map2Anna","Map2Anna - mean coverage","Map2Swift", "Map2Swift - mean coverage"),
  col=c("darkred","darkred","darkblue","darkblue"),lty=c("solid","dashed","solid","dashed"),lwd=2)

plot(d2Anna, type="l", col="darkred", lwd=2, ylim=c(0,maxY2), main="Without outliers", xlab="Depth of coverage")
points(d2Swift, type="l", col="darkblue", lwd=2)
abline(v=c(mean(anna.5$Coverage),mean(swift.6$Coverage)), col=c("darkred","darkblue"), lty="dashed",lwd=2)
legend("topright",legend=c("Map2Anna","Map2Anna - mean coverage","Map2Swift", "Map2Swift - mean coverage"),
  col=c("darkred","darkred","darkblue","darkblue"),lty=c("solid","dashed","solid","dashed"),lwd=2)


summarycoveragePerTarget=rbind(
  t(summary(anna.5$Coverage)),
  t(summary(swift.6$Coverage))
)
rownames(summarycoveragePerTarget)=c("map2Anna","map2Swift")
summarycoveragePerTarget[1:2,]=prettyNum(summarycoveragePerTarget[1:2,], big.mark=",")
kable(summarycoveragePerTarget, format="markdown")
```


<div class="panel panel-warning">
<div class="panel-heading">
<h3 class="panel-title">**Size outliers removal**</h3>
</div>
<div class="panel-body">

```{R, echo=F, fig.width=12}
qntAnna <- quantile(anna.5$Size, probs=c(.25, .75))
H <- 1.5 * IQR(anna.5$Size)
outliersTargetsAnna <- anna.5$Size
outliersTargetsAnna[anna.5$Size < (qntAnna[1] - H)] <- -1
outliersTargetsAnna[anna.5$Size > (qntAnna[2] + H)] <- -1
outliersTargetsAnna[outliersTargetsAnna>=0]=0
outliersTargetsAnna[outliersTargetsAnna<0]=1
numTargetsOutliersAnna=sum(outliersTargetsAnna)
indexOutliers=which(outliersTargetsAnna>0)
targetsOutliersAnna=data.frame(
  Target=anna.5$targetname[indexOutliers],
  Coverage=anna.5$Coverage[indexOutliers],
  Size=anna.5$Size[indexOutliers]
)
anna.6=anna.5[!(anna.5$targetname %in% targetsOutliersAnna$Target),]

# swift
qntSwift <- quantile(swift.6$Size, probs=c(.25, .75))
H <- 1.5 * IQR(swift.6$Size)
outliersTargetsSwift <- swift.6$Size
outliersTargetsSwift[swift.6$Size < (qntSwift[1] - H)] <- -1
outliersTargetsSwift[swift.6$Size > (qntSwift[2] + H)] <- -1
outliersTargetsSwift[outliersTargetsSwift>=0]=0
outliersTargetsSwift[outliersTargetsSwift<0]=1
numTargetsOutliersSwift=sum(outliersTargetsSwift)
indexOutliers=which(outliersTargetsSwift>0)
targetsOutliersSwift=data.frame(
  Target=swift.6$targetname[indexOutliers],
  Coverage=swift.6$Coverage[indexOutliers],
  Size=swift.6$Size[indexOutliers]
)
swift.7=swift.6[!(swift.6$targetname %in% targetsOutliersSwift$Target),]
```

- **Target size distribution**: Target size distribution has not change since the beginning of the analysis, current size distribution can be shown [here](#targeted-regions-size-distribution).
For a proper finding of correlation between size and coverage I had to remove both, size outliers and coverage outliers.

**Coverage distribution after removing outliers**

```{R, echo=F, fig.width=12}

d1=density(anna.6$Coverage)
d2=density(swift.7$Coverage)
maxY=max(d1$y,d2$y)
plot(d1,type="l",col="darkred", lwd=3,
  ylim=c(0,maxY),main="",
  xlab="Size (bp)")
points(d2,type="l", col="darkblue", lwd=3)
legend("topright", col=c("darkred","darkblue"),legend=c("Anna","Swift"),  lwd=3)

outliersDF=t(data.frame(
  anna=c(numTargetsOutliersAnna,summary(anna.6$Coverage)),
  swift=c(numTargetsOutliersSwift, summary(swift.7$Coverage))
  ))
colnames(outliersDF)=c("Num. outliers", "Min.","1st. Qu.","Median","Mean","3rd. Qu.","Max.")
rownames(outliersDF)=c("map2Anna", "map2Swift")
outliersDF[1:2,]=prettyNum(outliersDF[1:2,],big.mark=",")
kable(outliersDF, format="markdown")
```

**Size distribution after removing outliers**


```{R, echo=F, fig.width=12}
d1=density(anna.6$Size)
d2=density(swift.7$Size)
maxY=max(d1$y,d2$y)
plot(d1,type="l",col="darkred", lwd=3,
  ylim=c(0,maxY),main="",
  xlab="Size (bp)")
points(d2,type="l", col="darkblue", lwd=3)
legend("topright", col=c("darkred","darkblue"),legend=c("Anna","Swift"),  lwd=3)

outliersDF=t(data.frame(
  anna=c(numTargetsOutliersAnna,summary(anna.6$Size)),
  swift=c(numTargetsOutliersSwift, summary(swift.7$Size))
  ))
colnames(outliersDF)=c("Num. outliers", "Min.","1st. Qu.","Median","Mean","3rd. Qu.","Max.")
rownames(outliersDF)=c("map2Anna", "map2Swift")
outliersDF[1:2,]=prettyNum(outliersDF[1:2,],big.mark=",")
```
</div>
</div>




#### Target size vs. depth of coverage
<!-- http://blog.yhat.com/posts/r-lm-summary.html -->
<!-- http://data.princeton.edu/R/linearModels.html -->
<!-- http://feliperego.github.io/blog/2015/10/23/Interpreting-Model-Output-In-R -->

I'm looking for a relation between target size and depth of coverage.

```{R, echo=F, fig.width=12,fig.height=6}
lmdTargetAnna=lm(anna.6$Coverage~anna.6$Size)
lmdTargetSwift=lm(swift.7$Coverage~swift.7$Size)
layout(matrix(c(1,2),1,2))
plot(anna.6$Size,anna.6$Coverage, pch=20,
   xlab="Target size",ylab="Depth of coverage",axes=F, main="map2Anna")
abline(lmdTargetAnna, col="red",lwd=2)
axis(1);axis(2)
plot(swift.7$Size,swift.7$Coverage, pch=20,
   xlab="Target size",ylab="Depth of coverage",axes=F, main="map2Swift")
abline(lmdTargetSwift, col="red",lwd=2)
axis(1);axis(2)
```

<ul class="nav nav-tabs">
<li class="active"><a href="#lmdTargetAnna" data-toggle="tab">map2Anna summary(lmd)</a></li>
<li><a href="#lmdTargetSwift" data-toggle="tab">map2Swift summary(lmd)</a></li>
</ul>
<div id="myTabContent" class="tab-content">
<div class="tab-pane fade active in" id="lmdTargetAnna">

<div class="panel panel-default">
<div class="panel-body">
```{R, echo=F, fig.width=10,fig.height=8}
summary(lmdTargetAnna)
layout(matrix(c(1,2,3,4), 2,2, byrow=T))
plot(lmdTargetAnna, pch=16)
```
</div>
</div>

</div>
<div class="tab-pane fade" id="lmdTargetSwift">
<div class="panel panel-default">
<div class="panel-body">
```{R, echo=F,fig.width=10,fig.height=8}
summary(lmdTargetSwift)
layout(matrix(c(1,2,3,4), 2,2, byrow=T))
plot(lmdTargetSwift, pch=16)
```
</div>
</div>


</div>
</div> <!-- end div -->



<div class="panel panel-danger">
<div class="panel-heading">
<h3 class="panel-title"> CHECK THIS OUT!</h3>
</div>
<div class="panel-body">
I need to understand how to interpret this
</div>
</div>

## Overview

While there is no specific color key for the coverage values, this will only serve as an overview of the coverage per target/gene per sample.

- Yellow maximum coverage
- Red minimum coverage.


```{R, echo=F}
matrixAnnaFile="/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/files2/coverage.matrix.per.gene.txt"
matrixSwiftFile="/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/files2/coverage.matrix.per.gene.txt"
matrixAnna=as.matrix(read.table(matrixAnnaFile, stringsAsFactors=F,header=T))
rownames(matrixAnna)=unique(anna.3$V9)
geneSizesAnna=sapply(split(anna.3,anna.3$V9), function(x){sum(anna.3$V5-anna.3$V4)})
matrixAnna=matrixAnna/geneSizesAnna
matrixSwift=as.matrix(read.table(matrixSwiftFile, stringsAsFactors=F,header=T))
rownames(matrixSwift)=unique(swift.4$V9)
geneSizesSwift=sapply(split(swift.4,swift.4$V9), function(x){sum(swift.4$V5-swift.4$V4)})
matrixSwift=matrixSwift/geneSizesSwift
genesAnnaAfterOutlierRemoval=data.frame(  Gene=as.character(unique(anna.6$V9)),  Size=geneSizesAnna[unique(anna.6$V9)])
genesSwiftAfterOutlierRemoval=data.frame(  Gene=as.character(unique(swift.7$V9)),  Size=geneSizesSwift[unique(swift.7$V9)])


matrixTargetsAnnaFile="/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/files2/coverage.matrix.per.target.txt"
matrixTargetsSwiftFile="/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/files2/coverage.matrix.per.target.txt"
matrixTargetsAnna=as.matrix(read.table(matrixTargetsAnnaFile, stringsAsFactors=F,header=T))
rownames(matrixTargetsAnna)=anna.3$targetname
targetSizesAnna=anna.3$V5-anna.3$V4
matrixTargetsAnna=matrixTargetsAnna/targetSizesAnna
matrixTargetsSwift=as.matrix(read.table(matrixTargetsSwiftFile, stringsAsFactors=F,header=T))
rownames(matrixTargetsSwift)=swift.4$targetname
targetSizesSwift=swift.4$V5-swift.4$V4
matrixTargetsSwift=matrixTargetsSwift/targetSizesSwift

```

<ul class="nav nav-tabs">
<li class="active"><a href="#genes-small-dataset" data-toggle="tab">Genes (25 Genes  matrix)</a></li>
<li><a href="#genes-wholematrixreduced" data-toggle="tab">Genes (Complete Matrix - without outliers)</a></li>
<li><a href="#genes-wholematrix" data-toggle="tab">Genes (Complete Matrix)</a></li>
<li><a href="#targets-small-dataset" data-toggle="tab">Targets (25 Targets Matrix)</a></li>
<li><a href="#targets-wholematrixreduced" data-toggle="tab">Targets (Complete matrix - Wihtout outliers)</a></li>
<li><a href="#targets-wholematrix" data-toggle="tab">Targets (Complete matrix)</a></li>
</ul>
<div id="myTabContent" class="tab-content">

<div class="tab-pane fade active in" id="genes-small-dataset">
<div class="row">
<div class="col-lg-6">
<div class="bs-component">
```{R, echo=F, fig.width=12, fig.height=12}
smallMatrixGenesAnna=matrixAnna[genesAnnaAfterOutlierRemoval$Gene,]
heatmap(smallMatrixGenesAnna[1:25,],Rowv=NA,Colv=NA,labRow=NA)
```
</div>
</div>
<div class="col-lg-6">
<div class="bs-component">
```{R, echo=F, fig.width=12, fig.height=12}
smallMatrixGenesSwift=matrixSwift[genesSwiftAfterOutlierRemoval$Gene,]
heatmap(smallMatrixGenesSwift[1:25,],Rowv=NA,Colv=NA,labRow=NA)
```
</div>
</div>
</div>
</div>

<div class="tab-pane fade" id="genes-wholematrixreduced">
<div class="row">
<div class="col-lg-6">
<div class="bs-component">
```{R, echo=F, fig.width=12, fig.height=12}
heatmap(matrixAnna[genesAnnaAfterOutlierRemoval$Gene,],Rowv=NA,Colv=NA,labRow=NA)
```
</div>
</div>
<div class="col-lg-6">
<div class="bs-component">
```{R, echo=F, fig.width=12, fig.height=12}
heatmap(matrixSwift[genesSwiftAfterOutlierRemoval$Gene,],Rowv=NA,Colv=NA,labRow=NA)
```
</div>
</div>
</div>
</div>

<div class="tab-pane fade" id="genes-wholematrix">
<div class="row">
<div class="col-lg-6">
<div class="bs-component">
```{R, echo=F, fig.width=12, fig.height=12}
heatmap(matrixAnna,Rowv=NA,Colv=NA,labRow=NA)
```
</div>
</div>
<div class="col-lg-6">
<div class="bs-component">
```{R, echo=F, fig.width=12, fig.height=12}
heatmap(matrixSwift,Rowv=NA,Colv=NA,labRow=NA)
```
</div>
</div>
</div>
</div>


<div class="tab-pane fade" id="targets-small-dataset">
<div class="row">
<div class="col-lg-6">
<div class="bs-component">
```{R, echo=F, fig.width=12, fig.height=12}
smallMatrixTargetsAnna=matrixTargetsAnna[anna.6$targetname,]
heatmap(smallMatrixTargetsAnna[1:50,],Rowv=NA,Colv=NA,labRow=NA)
```
</div>
</div>
<div class="col-lg-6">
<div class="bs-component">
```{R, echo=F, fig.width=12, fig.height=12}
smallMatrixTargetsSwift=matrixTargetsSwift[swift.7$targetname,]
heatmap(smallMatrixTargetsSwift[1:50,],Rowv=NA,Colv=NA,labRow=NA)
```
</div>
</div>
</div>
</div>


<div class="tab-pane fade" id="targets-wholematrixreduced">
<div class="row">
<div class="col-lg-6">
<div class="bs-component">
```{R, echo=F, fig.width=12, fig.height=12}
heatmap(matrixTargetsAnna[anna.6$targetname, ],Rowv=NA,Colv=NA,labRow=NA)
```
</div>
</div>
<div class="col-lg-6">
<div class="bs-component">
```{R, echo=F, fig.width=12, fig.height=12}
heatmap(matrixTargetsSwift[swift.7$targetname,],Rowv=NA,Colv=NA,labRow=NA)
```
</div>
</div>
</div>
</div>




<div class="tab-pane fade" id="targets-wholematrix">
<div class="row">
<div class="col-lg-6">
<div class="bs-component">
```{R, echo=F, fig.width=12, fig.height=12}
heatmap(matrixTargetsAnna,Rowv=NA,Colv=NA,labRow=NA)
```
</div>
</div>
<div class="col-lg-6">
<div class="bs-component">
```{R, echo=F, fig.width=12, fig.height=12}
heatmap(matrixTargetsSwift, Rowv=NA,Colv=NA,labRow=NA)
```
</div>
</div>
</div>
</div>
</div>



## Genes not captured

- This is a summary of the genes that were not totally captured by a single base, per sample. Meaning, coverage is below 1x.

```{R, echo=F,fig.width=12}
matrixAnnaNC=matrixAnna
matrixSwiftNC=matrixSwift
matrixAnnaNC[matrixAnna!=0]=1
matrixSwiftNC[matrixSwift!=0]=1
nMatrixAnna=1-matrixAnnaNC
nMatrixSwift=1-matrixSwiftNC
rownames(nMatrixAnna)=rownames(matrixAnna)
rownames(nMatrixSwift)=rownames(matrixSwift)

smallMatrixAnnaNC=smallMatrixGenesAnna
smallMatrixSwiftNC=smallMatrixGenesSwift
smallMatrixAnnaNC[smallMatrixGenesAnna!=0]=1
smallMatrixSwiftNC[smallMatrixGenesSwift!=0]=1
nsmallMatrixAnnaNC=1-smallMatrixAnnaNC
nsmallMatrixSwiftNC=1-smallMatrixSwiftNC
rownames(nsmallMatrixAnnaNC)=rownames(nsmallMatrixAnnaNC)
rownames(nsmallMatrixSwiftNC)=rownames(nsmallMatrixSwiftNC)


maxY=roundUpNice(max(c(
  colSums(nMatrixAnna),
  colSums(nsmallMatrixAnnaNC),
  colSums(nMatrixSwift),
  colSums(nsmallMatrixSwiftNC))
))+10
# number of samples with a gene that was not captured
plot(c(0,colSums(nMatrixAnna),0),
     type="b",col="darkred",
     ylim=c(0.01,maxY),lwd=2, axes=F,
     xlab="Samples",ylab="Number of genes not covered (not a single base)"
   )
points(c(0,colSums(nsmallMatrixAnnaNC),0), type="b",col="red", lwd=2)   
points(colSums(nMatrixSwift), type="b",col="darkblue", lwd=2)
points(colSums(nsmallMatrixSwiftNC), type="b",col="blue", lwd=2)
axis(2);axis(1, at=1:48, labels = sampleNamesSwift, las=2)
legend("topright", col=c("darkred","red","darkblue","blue"),legend=c("Anna full", "Anna wo outliers","Swift full", "Swift wo outliers"),  lwd=3, pch=1)
```

- Are these genes the same per sample?
    - No, they are not. This is the list of genes not captured in the Swift dataset, taking into account that the Anna dataset has all genes with coverage  `>0x`.
    - H46 and H47 were samples with really low coverage, it can be expected to loose some genes when doing the capture.
    - Also for both datasets (full and without outliers) missing genes are the same

```{R,echo=F,fig.width=12}
# identify samples that have a not captured gene
samplesNotCoveredGenesInAnna=colnames(matrixAnna)[colnames(matrixAnna) %in% colnames(nMatrixAnna)[colSums(nMatrixAnna)>0]]
samplesNotCoveredGenesInSwift=colnames(matrixSwift)[colnames(matrixSwift) %in% colnames(nMatrixSwift)[colSums(nMatrixSwift)>0]]

genesNotCoveredPerSample=list()
for (i in 1:length(samplesNotCoveredGenesInSwift)){
  genesNotCoveredPerSample[[i]]=rownames(nMatrixSwift)[nMatrixSwift[,samplesNotCoveredGenesInSwift[i]] > 0]
}
intersectedGenes=Reduce(intersect,genesNotCoveredPerSample)


samplesNotCoveredGenesInAnna=colnames(smallMatrixGenesAnna)[colnames(smallMatrixGenesAnna) %in% colnames(nsmallMatrixAnnaNC)[colSums(nsmallMatrixAnnaNC)>0]]
samplesNotCoveredGenesInSwift=colnames(smallMatrixGenesSwift)[colnames(smallMatrixGenesSwift) %in% colnames(nsmallMatrixSwiftNC)[colSums(nsmallMatrixSwiftNC)>0]]

genesNotCoveredPerSampleS=list()
for (i in 1:length(samplesNotCoveredGenesInSwift)){
  genesNotCoveredPerSampleS[[i]]=rownames(nsmallMatrixSwiftNC)[nsmallMatrixSwiftNC[,samplesNotCoveredGenesInSwift[i]] > 0]
}

intersectedGenesS=Reduce(intersect,genesNotCoveredPerSampleS)


df=data.frame(genesFull=unlist(genesNotCoveredPerSample),
  genesWOout=unlist(genesNotCoveredPerSampleS))
colnames(df)=c("Full (1.469 Genes)", "Without Outliers")

kable(df, format="markdown")
```



## Targeted regions not captured

This is a summary of the target regions that were not captured by a single base, per sample.

```{R, echo=F,fig.width=12}
targetsAnnaAfterOutliersRemoval=matrixTargetsAnna[anna.6$targetname,]
targetsSwiftAfterOutliersRemoval=matrixTargetsSwift[swift.7$targetname,]


matrixAnnaNC=matrixTargetsAnna
matrixSwiftNC=matrixTargetsSwift
matrixAnnaNC[matrixTargetsAnna!=0]=1
matrixSwiftNC[matrixTargetsSwift!=0]=1
nMatrixAnna=1-matrixAnnaNC
nMatrixSwift=1-matrixSwiftNC
rownames(nMatrixAnna)=rownames(matrixTargetsAnna)
rownames(nMatrixSwift)=rownames(matrixTargetsSwift)

smallMatrixAnnaNC=smallMatrixTargetsAnna
smallMatrixSwiftNC=smallMatrixTargetsSwift
smallMatrixAnnaNC[smallMatrixTargetsAnna!=0]=1
smallMatrixSwiftNC[smallMatrixTargetsSwift!=0]=1
nsmallMatrixAnnaNC=1-smallMatrixAnnaNC
nsmallMatrixSwiftNC=1-smallMatrixSwiftNC
rownames(nsmallMatrixAnnaNC)=rownames(smallMatrixTargetsAnna)
rownames(nsmallMatrixSwiftNC)=rownames(smallMatrixTargetsSwift)



maxY=roundUpNice(max(c(
  colSums(nMatrixAnna),
  colSums(nsmallMatrixAnnaNC),
  colSums(nMatrixSwift),
  colSums(nsmallMatrixSwiftNC))
))+200
# number of samples with a gene that was not captured
plot(c(0,colSums(nMatrixAnna),0),
     type="b",col="darkred",
     ylim=c(0.01,maxY),lwd=2, axes=F,
     xlab="Samples",ylab="Number of targets not covered (not a single base)"
   )
points(c(0,colSums(nsmallMatrixAnnaNC),0), type="b",col="red", lwd=2)   
points(colSums(nMatrixSwift), type="b",col="darkblue", lwd=2)
points(colSums(nsmallMatrixSwiftNC), type="b",col="blue", lwd=2)
axis(2);axis(1, at=1:48, labels = sampleNamesSwift, las=2)
legend("topright", col=c("darkred","red","darkblue","blue"),legend=c("Anna full", "Anna wo outliers","Swift full", "Swift wo outliers"),  lwd=3, pch=1)

```

```{R,echo=F,fig.width=12}
# identify samples that have a not captured gene
samplesNotCoveredTargetsInAnna=colnames(matrixTargetsAnna)[colnames(matrixTargetsAnna) %in% colnames(nMatrixAnna)[colSums(nMatrixAnna)>0]]
samplesNotCoveredTargetsInSwift=colnames(matrixTargetsSwift)[colnames(matrixTargetsSwift) %in% colnames(nMatrixSwift)[colSums(nMatrixSwift)>0]]
samplesNotCoveredTargetsInAnnaWO=colnames(targetsAnnaAfterOutliersRemoval)[colnames(targetsAnnaAfterOutliersRemoval) %in% colnames(nsmallMatrixAnnaNC)[colSums(nsmallMatrixAnnaNC)>0]]
samplesNotCoveredTargetsInSwiftWO=colnames(targetsSwiftAfterOutliersRemoval)[colnames(targetsSwiftAfterOutliersRemoval) %in% colnames(nsmallMatrixSwiftNC)[colSums(nsmallMatrixSwiftNC)>0]]

targetsNotCoveredPerSampleAnna=list();targetsNotCoveredPerSampleAnnaWO=list()
targetsNotCoveredPerSampleSwift=list();targetsNotCoveredPerSampleSwiftWO=list()
for (i in samplesNotCoveredTargetsInAnna){
  targetsNotCoveredPerSampleAnna[[i]]=rownames(nMatrixAnna)[nMatrixAnna[,i]>0]
}
for (i in samplesNotCoveredTargetsInSwift){
  targetsNotCoveredPerSampleSwift[[i]]=rownames(nMatrixSwift)[nMatrixSwift[,i]>0]
}

for (i in samplesNotCoveredTargetsInAnnaWO){
  targetsNotCoveredPerSampleAnnaWO[[i]]=rownames(nMatrixAnna)[nMatrixAnna[,i]>0]
}
for (i in samplesNotCoveredTargetsInSwiftWO){
  targetsNotCoveredPerSampleSwiftWO[[i]]=rownames(nMatrixSwift)[nMatrixSwift[,i]>0]
}

intersectedTargetsAnna=Reduce(intersect,targetsNotCoveredPerSampleAnna)
intersectedTargetsSwift=Reduce(intersect,targetsNotCoveredPerSampleSwift)
intersectedTargetsAnnaWO=Reduce(intersect,targetsNotCoveredPerSampleAnna)
intersectedTargetsSwiftWO=Reduce(intersect,targetsNotCoveredPerSampleSwift)
intersectBoth=intersect(list(intersectedTargetsAnna), list(intersectedTargetsSwift)) # this is empty
intersectBothWO=intersect(list(intersectedTargetsAnnaWO), list(intersectedTargetsSwiftWO)) # this is empty

df=data.frame(
  intersectedTargetsAnnaNum=c(length(intersectedTargetsAnna),length(intersectedTargetsAnna)/nrow(nMatrixAnna)),
  intersectedTargetsAnnaNumWO=c(length(intersectedTargetsAnnaWO),length(intersectedTargetsAnnaWO)/nrow(nsmallMatrixAnnaNC)),
  intersectedTargetsSwiftNum=c(length(intersectedTargetsSwift),length(intersectedTargetsSwift)/nrow(nMatrixSwift)),
  intersectedTargetsSwiftNumWO=c(length(intersectedTargetsSwiftWO),length(intersectedTargetsSwiftWO)/nrow(nsmallMatrixSwiftNC)),
  intersectedTargetsBothNum=c(length(intersectBoth),0),
  intersectedTargetsBothNumWO=c(length(intersectBothWO),0)
)
df[2,]=df[2,]*100
df=rbind(df,c("Full dataset" ,"Outliers removed" ,"Full dataset" ,"Outliers removed" ,"Full Dataset" ,"Outliers removed"))
colnames(df)=c(
  "Within map2Anna samples",
  "Within map2Anna samples",
  "Within map2Swift samples",
  "Within map2Swift samples",
  "Across datasets",
  "Across datasets"
)
rownames(df)=c("Number of common target regions per sample", "Percentage (common target/total target regions)","Dataset")
df=df[c(3,1,2),]
kable(t(df), format="markdown")
```

- This shows that there are not common target regions across datasets.
- Makes sense that they do not match, because the target file of the map2Swift was
match (by genes) to the `map2Anna` target file, and coordinates are different
- Makes sense that the number of targets not covered is lower in the `map2Swift`
dataset, due to the lower number of targets in general, even though the percentages
are similar (1%)
- Also, the differences between the with/without outliers datasets are consistent to
the removal of outliers
- Common target regions are still the same.
- I cannot find a possible reason why these regions where not captured, but the
fact that such targets simply did not work.
- Then, going through the sizes of those targets, it does not show much, mean size
 is ~130 bp, which is close to the size of the probes.

```{R, echo=F, fig.width=12,fig.height=6}
a1=anna.6$Size
a2=swift.7$Size
d1=density(a1)
d2=density(a2)
maxY=max(d1$y,d2$y)
plot(d1,type="l", col="red", ylim=c(0,maxY), xlab="Target size", main="",lwd=2)
points(d2,type="l", col="blue", lwd=2)
abline(v=mean(a1), col="red", lty="dashed", lwd=2)
abline(v=mean(a2), col="blue",  lty="dashed", lwd=2)
legend("topright", legend=c("Mean size of non recovered targets in map2Anna","Mean size of non recovered targets in map2Swift"), col=c("red","blue"), lty="dashed", lwd=2)
summarydf=data.frame(rbind(t(summary(a1)),t(summary(a2))))
summarydf[1:2,]=rbind(
  prettyNum(summarydf[1,], big.mark=","),
  prettyNum(summarydf[2,], big.mark=",")
)
colnames(summarydf)=c("Min.","1st. Qu.","Median", "Mean","3rd. Qu","Max.")
rownames(summarydf)=c("Anna","Swift")
kable(summarydf,format="markdown"  )
```





# Off-target regions

## Generation of on and off target datasets


First, is important to define what is an off-target region. For the purpose of this analysis, there are two (`2`) definition
of an off-target region.

1. The first definition considers off-target regions as the difference between the genome that can be captured and the regions in the targets file.
2. The second definition considers off-target regions as a set difference between the genome that can be captured and the codon regions in `Calypte_anna.gene.CDS.2750.2.gff` and the regions in `Chaetura_pelagica.CDS.2.gff`, for their corresponding dataset.
    - This is the definition that is going to be used. This is due to the fact that codon regions in each file correspond to those genes that are known to be orthologs.
    There is a possibility that there might be potential orthologs within the rest of the genes, and so is possible that some of the reads may have mapped to those genes
    due to the similarity of the regions.


I'm assuming that the all the possible DNA captured (on/off-target) is defined by a set of scaffolds in each `GFF` file.
The information that we know is the position of the codons per dataset (represented in the darker box, bottom), the
`Calypte_anna.gene.CDS.2750.gff` file, for the `map2Anna` dataset and the `Chaetura_pelagica.CDS.2.gff` for the `map2Swift` dataset.
These positions are relative to the scaffold that represents a region of the genome that was able to be assembled. We also have
the relation of the codons to their corresponding genes.

![***Off-target generation***](/home/merly/git/cph-visit/coverage-analysis/empirical/imgs/offtarget.generation.png)

So, in order to know what was the size of the off-target regions, I first needed to obtain the size of the possible DNA to be captured,
meaning on and off target. To do so, I (per file):

1. Grouped targets per scaffolds
2. From those targets, extracted the highest end position, which would be the highest position possible per scaffold and therefore, the definition of the scaffold size.
3. Generated a file, where  I would have all the scaffold regions defined, considering that all scaffolds regions start at position 1, and end in their highest position.
```{R, eval=F}
WD="/media/merly/Baymax/research/cph-visit/coverage-analysis/"
allgenes=paste0(WD,"files/Calypte_anna.gene.CDS.gff")
anna=read.table(allgenes, colClasses = c("character","character","character",
                                         "numeric","numeric","character",
                                         "character","character","character"))
swiftfull=paste0(WD,"files/Chaetura_pelagica.CDS.gff")
swift=read.table(swiftfull, colClasses = c("character","character","character",
                                         "numeric","numeric","character",
                                         "character","character","character"))
sAnnaAll=split(anna,anna$V1)
sSwiftAll=split(swift,swift$V1)
maxPositionPerScaffoldAnna=sapply(sAnnaAll,function(x){max(x$V5)})
maxPositionPerScaffoldSwift=sapply(sSwiftAll,function(x){max(x$V5)})

maxLen=max(
  length(maxPositionPerScaffoldAnna),
  length(maxPositionPerScaffoldSwift))
unionScaffolds=union(
  names(maxPositionPerScaffoldAnna),
  names(maxPositionPerScaffoldSwift))
df=data.frame(
  anna=rep(0,length(unionScaffolds)),
  swift=rep(0,length(unionScaffolds)))
rownames(df)=unionScaffolds

df[names(maxPositionPerScaffoldAnna),]$anna=maxPositionPerScaffoldAnna[names(maxPositionPerScaffoldAnna)]
df[names(maxPositionPerScaffoldSwift),]$swift=maxPositionPerScaffoldSwift[names(maxPositionPerScaffoldSwift)]

dfAnna=df$anna[df$anna!=0]
names(dfAnna)=rownames(df)[df$anna!=0]
finalBed=cbind(names(dfAnna),rep(1,length(dfAnna)),dfAnna)
write.table(finalBed,paste0(WD,"files/scaffolds.anna.bed"), row.names = F,col.names = F,quote = F, sep="\t")

dfSwift=df$swift[df$swift!=0]
names(dfSwift)=rownames(df)[df$swift!=0]
finalBed=cbind(names(dfSwift),rep(1,length(dfSwift)),dfSwift)
write.table(finalBed,paste0(WD,"files/scaffolds.swift.bed"), row.names = F,col.names = F,quote = F, sep="\t")
```

4. Used [`bedtools subtract`](http://bedtools.readthedocs.io/en/latest/content/tools/subtract.html) (searches for features in B that overlap A. If an overlapping feature is found in B, the overlapping portion is removed from A and the remaining portion of A is reported) to removed all possible targets from the `GFF` files out of their corresponding ***scaffolds*** file,
obtaining two (`2`) `BED` files, one per dataset.

```{bash, eval=F}
bedtools subtract -a scaffolds.anna.bed -b $gffAnna > "$HOME/files/offtarget.anna.bed" &
bedtools subtract -a scaffolds.anna.bed -b $gffSwift > "$HOME/files/offtarget.swift.bed" &
```


```{R, echo=F}
scaffoldsAnnaFile="/media/merly/Baymax/research/cph-visit/coverage-analysis/files/scaffolds.anna.bed"
scaffoldsSwiftFile="/media/merly/Baymax/research/cph-visit/coverage-analysis/files/scaffolds.swift.bed"
scaffoldsAnna=read.table(scaffoldsAnnaFile, colClasses=c("character","numeric","numeric"))
scaffoldsSwift=read.table(scaffoldsSwiftFile, colClasses=c("character","numeric","numeric"))
basesScaffoldsAnna=sum(scaffoldsAnna$V3)
basesScaffoldsSwift=sum(scaffoldsSwift$V3)
offtargetsAnnaFile="/media/merly/Baymax/research/cph-visit/coverage-analysis/files/offtarget.anna.bed"
offtargetsSwiftFile="/media/merly/Baymax/research/cph-visit/coverage-analysis/files/offtarget.swift.bed"
offtargetsAnna=read.table(offtargetsAnnaFile, colClasses=c("character","numeric","numeric"))
offtargetsSwift=read.table(offtargetsSwiftFile, colClasses=c("character","numeric","numeric"))
offtargetsAnna$Size=offtargetsAnna$V3-offtargetsAnna$V2
offtargetsSwift$Size=offtargetsSwift$V3-offtargetsSwift$V2

dfofftargets=data.frame(
  numScaffolds=prettyNum(c(nrow(scaffoldsAnna),nrow(scaffoldsSwift)), big.mark=","),
  totalSizeGenome=prettyNum(c(basesScaffoldsAnna,basesScaffoldsSwift), big.mark=","),
  numTargetsOfftarget=prettyNum(c(nrow(offtargetsAnna), nrow(offtargetsSwift)), big.mark=","),
  sizeGenomeOfftarget=prettyNum(c(sum(offtargetsAnna$Size), sum(offtargetsSwift$Size)), big.mark=",")
)
colnames(dfofftargets)=c("Number of scaffolds", "Total Genome Size (scaffolds)", "Number of resulting targets", "Total Genome Size (Off-target)")
rownames(dfofftargets)=c("Anna","Swift")

dfofftargetsizes=data.frame(
  scaffoldSizeAnna=c("Scaffold",prettyNum(t(summary(scaffoldsAnna$V3)), big.mark=",")),
  scaffoldSizeSwift=c("Scaffold",prettyNum(t(summary(scaffoldsSwift$V3)), big.mark=",")),
  targeSizeAnna=c("Target",prettyNum(t(summary(offtargetsAnna$Size)), big.mark=",")),
  targeSizeSwift=c("Target",prettyNum(t(summary(offtargetsSwift$Size)), big.mark=","))
)
rownames(dfofftargetsizes)=c("Unit","Min.","1st. Qu.","Median", "Mean","3rd. Qu","Max.")
colnames(dfofftargetsizes)=c("Anna","Swift","Anna","Swift")
dfofftargetsizes=t(dfofftargetsizes)
```

***General overview of scaffolds and resulting off-target regions***

```{R, echo=F}
kable(dfofftargets, format="markdown")
```

***General overview of the size distribution of off-target regions***

```{R, echo=F}
kable(dfofftargetsizes, format="markdown")
```

## Off-target regions across samples

The idea is to identify the off-target regions, as well as the size that covers and how is the coverage distribution within this regions compared to the on-target coverage.

To obtain coverage information from the off-target regions:

```{bash, eval=F}
for bamfile in $(find $originalsAnna -name "*.bam" ); do
  tag=$(echo $(basename $bamfile) | tr "_" " " | awk '{print $1}')
  nohup bedtools coverage -hist -abam $bamfile -b "$HOME/files/offtarget.anna.bed" | gzip > $HOME/anna/bedtools/cov2/${tag}.cov.gz &
done
for bamfile in $(find $originalsSwift -name "*.bam"  ); do
  tag=$(echo $(basename $bamfile) | tr "_" " " | awk '{print $1}')
  nohup bedtools coverage -hist -abam $bamfile -b "$HOME/files/offtarget.swift.bed" | gzip > $HOME/swift/bedtools/cov2/${tag}.cov.gz &
done
#  hist split
for tag in $(cat $HOME/anna/files/samples.txt  ); do
  zcat $HOME/anna/bedtools/cov2/$tag.cov.gz | grep -v ^all | gzip > $HOME/anna/bedtools/nohist2/$tag.nohist.gz
  zcat $HOME/anna/bedtools/cov2/$tag.cov.gz | grep ^all | gzip > $HOME/anna/bedtools/hist2/$tag.hist.gz
done
for tag in $(cat $HOME/swift/files/samples.txt  ); do
  zcat $HOME/swift/bedtools/cov2/$tag.cov.gz | grep -v ^all | gzip > $HOME/swift/bedtools/nohist2/$tag.nohist.gz
  zcat $HOME/swift/bedtools/cov2/$tag.cov.gz | grep ^all | gzip > $HOME/swift/bedtools/hist2/$tag.hist.gz
done
```

## Breadth vs. depth of coverage

I followed what has been done for the on-target regions to get this information. Getting how much of the off-target regions was captured, and at which depth.

| `map2Anna` | `map2Swift`      |
|------------|------------------|
|![](/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/img2/2.breadth.vs.coverage.2.zoom.500.offtarget1.png)| ![](/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/img2/2.breadth.vs.coverage.2.zoom.500.offtarget1.png)|
|  X-axis: 0-20 | X-axis: 0-20 |

- For the `map2Anna` dataset, for both off-target sets breadth vs. depth looks the same. Same situation with the `mat2Swift` dataset.
- For the `map2Anna`, we see that the general depth is low, 25% of the off-target regions are covered at 1x for most of the samples.
- For the `map2Swift`, we see that there are 3  situations:
    - Swift sample is the one that has more coverage in general (gray thick line)
    - Anna and H10 have a "medium" level coverage
    - Rest of the sample behaves in the same way as in the other dataset.
    - For Anna and Swift samples makes sense that the general off-target coverage is higher because these to sample datasets come from a whole-genome sequencing (WGS) experiment.

## Depth of coverage
### Coverage per sample

```{R,echo=F, fig.width=12}
perSampleAnna1=unlist(read.table("/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/files/offtarget1.coverage.per.sample.txt"))
perSampleSwift1=unlist(read.table("/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/files/offtarget1.coverage.per.sample.txt"))
perSampleAnna1=c(0,perSampleAnna1,0) # counting for those samples that are not in map2Anna but are in map2Swift

plot(1:48,perSampleAnna1,type="l",lwd=2,lty="solid", axes=F,col="darkred", ylim=c(0,1), ylab="Depth of coverage", xlab="Samples")
lines(1:48,perSampleSwift1,lwd=2,lty="solid", col="darkblue")
axis(2); axis(1,at=1:48,labels=sampleNamesSwift, las=2)

legend("topright",
  col=c("darkred","darkblue"),
  lwd=2,
  legend=c("map2Anna","map2Swift"))
```

- The 0x coverage for `AnnaBGI` and `SwiftBGI` in the `map2Anna` datasets, is because these samples were not in that mapping.
- It is possible to see that the general coverage of the off-target regions is **< 1x** for all the samples. Less than 1% of the on-target coverages seen.

### Coverage per target
```{R,echo=F, fig.width=15, fig.height=8}
targetAnna1=unlist(read.table("/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/files/offtarget1.coverage.per.target.txt"))
targetSwift1=unlist(read.table("/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/files/offtarget1.coverage.per.target.txt"))

summaryCoverageOffTarget=data.frame(
  rbind(
    t(summary(targetAnna1)),
    t(summary(targetSwift1))
  )
)
summaryCoverageOffTarget$Var=c(
  var(targetAnna1),
  var(targetSwift1)
  )
summaryCoverageOffTarget$Std.Dev=c(
  sd(targetAnna1),
  sd(targetSwift1)
  )
for (i in 1:nrow(summaryCoverageOffTarget)){
  summaryCoverageOffTarget[i,]=prettyNum(summaryCoverageOffTarget[i,], big.mark=",", preserve.width="individual")
}
colnames(summaryCoverageOffTarget)=c("Min.","1st. Qu.","Median", "Mean","3rd. Qu","Max.","Var.","Std. Dev")
rownames(summaryCoverageOffTarget)=c("map2Anna","map2Swift")

kable(summaryCoverageOffTarget, format="markdown")
```

- Most of the targets are below 21x
- The coverage among targets has a really high variability.


<!-- ## ANGSD Depth calculations

This computes depth distribution for every sample and for all samples jointly. Computed wiht ANGSD [angsdÂ version:Â 0.916Â (htslib:Â 1.3.2)Â build(MayÂ Â 2Â 2017Â 16:21:49)].

```
angsd -bam bam.filelist -doDepth 1 -out all -doCounts 1 -maxDepth 1000
```

Output of ANGSD are 2 files:

- `.depthSample`: This file contains nInd number of lines. Column1 is the number sites that has sequencing depth=0,Column2 is the number of sites that has sequencing depth=1 etc

- `.depthGlobal`: The sequencing depth for all samples. -->


<!-- | Map2 - target | All reads | On-target | Off-target |
|---------------|-----------|-----------|------------|
| `map2Anna`   |![](/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/img/5.angsd.depth.all.map2Anna.png)|![](/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/img/5.angsd.depth.targeted.map2Anna.png)|![](/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/img/5.angsd.depth.untargeted.map2Anna.png)|
| `map2Swift`   |![](/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/img/5.angsd.depth.all.map2Swift.png)|![](/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/img/5.angsd.depth.targeted.map2Swift.png)|![](/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/img/5.angsd.depth.untargeted.map2Swift.png)|
 -->

# Relation within coverage and phylogenetic distance

I am trying to analyze if there is any correlation between the depth of coverage and the phylogenetic distance from the reference species, used for the probe generation and mapping.

## Phylogenetic reconstruction

Information of the phylogenetic reconstruction I got from the Hummingbirds Paper, this says that it was made with mitochondrial genome and nuclear gene trees using either a concatenation approach with RAxML [[3]](#raxml) or the multi-species coalescent approach implemented in ASTRAL [[4]](#astral) and ASTRAL-II [[5]](#astralii).

The phylogenies were built using subsets of the nuclear genes present the same topology between the main groups of hummingbirds with high confidence.
The three subsets correspond to:

1. the 2949 genes that were successfully captured (in a minimum of 8 species)
2. the 1987 genes for which we could assign a high confidence swift orthologs determined in [[5]](#jarvis) (used as a root)
3. the 741 genes within the latter that produced trees with average support above 50%.

This is the Supplementary Table S5 (from the Hummingbirds Paper), describing the subsets selected:


| number of genes     | minimum number of sites per species (concatenated) | maximum number of sites per species (concatenated) | includes outgroup | ASTRAL score |
|---------------------|----------------------------------------------------|----------------------------------------------------|-----------------|--------------|
| 741                 | 949,470                                       |   1,542,750  |                 yes| 87%|
| 1987                | 1,667,071                                     |   2,783,832  |                 yes |78%|
| 2949                | 2,473,664                                     |   3,792,500  |                      | |

![***Maximum likelihood tree***](/media/merly/Baymax/research/cph-visit/img/inferred.phylogeny.png)

- `Cpe`, outgroup reference.
- `Aan`, ingroup reference.



## Depth of coverage vs. phylogenetic distance

For the analysis shown above as well as for phylogeny reconstruction using the dataset (1) with **2,949** genes.

### Overview
To obtain the distance matrix I used the tree obtained with RAxML, from the concatenation of 2,750 genes. The tree gives me the branch lengths in number of substitutions per site. So, the distance calculated here, is the pairwise distance of the tips. This was done with the R package `phangorn` [[7]](#phangorn), and its `cophenetic` function.

```{R}
sampleColors = colorRampPalette(brewer.pal(9, "Set1"))(48)
treefile="/home/merly/git/cph-visit/coverage-analysis/capture-phylotenetic-decay/trees/RAxML_bipartitions.2011.concat"
tree=read.nexus(treefile)
distMatrix=cophenetic(tree)
dCpe=distMatrix["Cpe",]
dAan=distMatrix["Aan",]
distMatrix[upper.tri(distMatrix)]=NA
```
<!-- <div class="row">
<div class="col-lg-6">
<div class="bs-component">
![Distance matrix](/media/merly/Baymax/research/cph-visit/img/distance.matrix.inferred.phylogeny.png)
</div>
</div>
<div class="col-lg-6">
<div class="bs-component"> -->
```{R, echo=F, fig.width=12,fig.heigth=6}
plot(dCpe[names(dCpe)], type="b",pch=20, col="darkblue", axes=F,
ylim=c(0,0.2),lwd=2,
xlab="Samples",ylab="Phylogenetic distance")
points(dAan[names(dCpe)], type="b", col="darkred", lwd=2)
axis(2, las=2);axis(1,at=1:length(dCpe),labels=names(dCpe),las=2)
legend("topright",legend=c("Distance to Outgroup (Cpe/Swift)","Distance to ingroup (Anna)"),
pch=c(20,1),
lwd=2, col=c("darkblue","darkred"))
```
<!-- </div>
</div>
</div> -->

Following the figure F3A in Braggs's paper [[8]](#braggs), where  it shows sequencing coverage as a function of genetic divergence.
 I have calculated the depth of coverage for both datasets and phylogenetic distance. In the plot below you can see the median target coverage
 per sample.

```{R, echo=F, fig.width=15,fig.height=12}
matrixAnnaFile="/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/files/coverage.matrix.per.target.txt"
matrixSwiftFile="/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/files/coverage.matrix.per.target.txt"
matrixAnna=as.matrix(read.table(matrixAnnaFile, stringsAsFactors=F,header=T))
matrixSwift=as.matrix(read.table(matrixSwiftFile, stringsAsFactors=F,header=T))
matrixAnna=matrixAnna/targets$Size
matrixSwift=matrixSwift/targetsSwift$Size
labelsCorrect=c("H05","H01","H08","H03","H04","H06","H02","H07")
labelsWronglyFormated=c("H5","H1","H8","H3","H4","H6","H2","H7")
cpe=dCpe[! names(dCpe) %in% c("Cpe","Aan")]
aan=dAan[! names(dAan) %in% c("Cpe","Aan")]
namesIds=which(names(aan)%in%labelsCorrect)
names(aan)[namesIds]=labelsWronglyFormated
namesIds=which(names(cpe)%in%labelsCorrect)
names(cpe)[namesIds]=labelsWronglyFormated
# matrixAnna=matrixAnna/genesAnna$Size
# matrixSwift=matrixSwift/genesSwift$Size
mediansPerSampleAnna=apply(matrixAnna,2,median)
mediansPerSampleSwift=apply(matrixSwift,2,median)
quantilesAnna=apply(matrixAnna[,names(aan)],2,quantile,c(0.25,0.75))
quantilesSwift=apply(matrixSwift[,names(cpe)],2,quantile,c(0.25,0.75))

disCoverageAnna=data.frame(distance=aan,
  median=mediansPerSampleAnna[names(aan)],
  q1=quantilesAnna[1,],
  q3=quantilesAnna[2,]
  )

disCoverageSwift=data.frame(distance=cpe,
  median=mediansPerSampleSwift[names(cpe)],
  q1=quantilesSwift[1,],
  q3=quantilesSwift[2,]
  )

maxDistanceX=max(disCoverageAnna$distance,disCoverageSwift$distance)
maxCoverageY=max(disCoverageAnna$q3,disCoverageSwift$q3)


layout(matrix(c(1,2),1,2,byrow=T))
plot(disCoverageAnna$distance,
     disCoverageAnna$median,
     xlim=c(0,maxDistanceX),
     ylim=c(0,maxCoverageY),
     xlab="Phylogenetic distance",ylab="Depth of coverage",
     pch=20, col=sampleColors, main = "Distance to ingroup (Anna)")
arrows(disCoverageAnna$distance,disCoverageAnna$q1,
       disCoverageAnna$distance,disCoverageAnna$q3,
       length = 0.05,angle=90, code=3,col=sampleColors)
plot(disCoverageSwift$distance,
    disCoverageSwift$median,
    xlim=c(0,maxDistanceX),
    ylim=c(0,maxCoverageY),
    xlab="Phylogenetic distance",ylab="Depth of coverage",
    pch=20, col=sampleColors, main = "Distance to outgroup (Swift)")
arrows(disCoverageSwift$distance,disCoverageSwift$q1,
      disCoverageSwift$distance,disCoverageSwift$q3,
      length = 0.05,angle=90, code=3,col=sampleColors)
legend("topleft", legend=rownames(disCoverageSwift), col=sampleColors, lty=1, lwd=2, cex=.9)
```


### Detailed All

After genes with missing data were removed leaving **2,750 genes**, and after matching those genes to the ones available in Swift, **1,469**.    

For the phylogenetic distance vs. coverage analysis, I will used a smaller dataset (2), with **1,987** genes, which I will intersect with those from which I do
have the coverage information.

To do that, I generated a new dataset from the intersection of the genes found in `Calypte_anna.gene.CDS.2750.3.gff` (**1,469**), which are those
ortholog genes matching across datasets,  and the available gene trees  (**1,988**).

```{bash, eval=F}

cat "$WD/files/Calypte_anna.gene.CDS.2750.3.gff" | cut -f9 | uniq | tr "_" " " | awk '{print $2}' | tr ";" " " > g.trees.to.filter.txt

for gtreefile in $(cat $WD/files/g.trees.to.filter.txt); do
  cp "$WD/trees/gtrees/$gtreefile" "$WD/trees/gtrees.2/"
done
```

- Gene trees not found: `R001806, R005562, R009279, R014527, R014590`.
- Resulting on **1,464** genes.
- Trees didn't have branch lengths, I moved to the available multiple-sequence alignments (MSA), from which only **741** could be retrieved.

```{bash, eval=F}
ls "$WD/trees/seqs" | tr "." " " | awk '{print $1}'  > "$WD/files/g.trees.to.filter.seqs.2.txt"
```

- From those, I generated a smaller subset of gene trees MSAs.

```{bash, eval=F}
mkdir "$WD/trees/seqs.2"
for gtreefile in $(cat $WD/files/g.trees.to.filter.seqs.2.txt); do
  filename="$WD/trees/seqs/${gtreefile}.x.aa.aln.backTranslated.gz"
  cp $filename "$WD/trees/seqs.2/"
done
```

- I calculated the pairwise *Hamming distance* of the resulting gene trees MSAs, and extracted the vectors belonging to the
distances to `Anna` and to `Swift`.

```{R, eval=F}
geneList=unlist(read.table(paste0(WD,"files/g.trees.to.filter.seqs.2.txt"), stringsAsFactors=F))
distancesAnna=matrix(rep(0,length(geneList)*length(sampleNamesSwift)), length(geneList), length(sampleNamesSwift))
distancesSwift=matrix(rep(0,length(geneList)*length(sampleNamesSwift)), length(geneList), length(sampleNamesSwift))
rownames(distancesAnna)=geneList; colnames(distancesAnna)=sampleNamesSwift;
rownames(distancesSwift)=geneList; colnames(distancesSwift)=sampleNamesSwift

gtreefiles <- list.files(
  path = paste0(WD,"trees/seqs.2/"),
  pattern="*.x.aa.aln.backTranslated")
gtreefiles=paste0(WD,"trees/seqs.2/",gtreefiles)
labelsCorrect=c("H05","H01","H08","H03","H04","H06","H02","H07")
labelsWronglyFormated=c("H5","H1","H8","H3","H4","H6","H2","H7")

for (i in 1:length(gtreefiles)) {
  print(i)
  msa=as.phyDat(read.FASTA(gzfile(gtreefiles[i])))
  hammDist=as.matrix(dist.hamming(msa))
  indexAnna=which(startsWith(rownames(hammDist),"Aan"))
  indexSwift=which(startsWith(rownames(hammDist),"Cpe"))
  namesIds=which(rownames(hammDist) %in% labelsCorrect)
  rownames(hammDist)[c(indexAnna, indexSwift, namesIds)]=c("AnnaBGI","SwiftBGI",labelsWronglyFormated)
  colnames(hammDist)[c(indexAnna, indexSwift, namesIds)]=c("AnnaBGI","SwiftBGI",labelsWronglyFormated)
  gene=strsplit(basename(gtreefiles[i]),"\\.")[[1]][1]
  distancesAnna[gene,colnames(distancesAnna)]=hammDist[indexAnna,colnames(distancesAnna)]
  distancesSwift[gene,colnames(distancesSwift)]=hammDist[indexSwift,colnames(distancesSwift)]
}
write.table(distancesAnna,file=paste0(WD,"files/distance.matrix.per.gene.anna.txt"), col.names=T,row.names=T)
write.table(distancesSwift,file=paste0(WD,"files/distance.matrix.per.gene.swift.txt"), col.names=T,row.names=T)
```

- Afterwards, I filtered them to match those genes from which coverage was calculated.
Leaving a total of  **623** genes to work with.

```{R, eval=F}
distancesAnna=read.table(file=paste0(WD,"files/distance.matrix.per.gene.anna.txt"), header=T)
distancesSwift=read.table(file=paste0(WD,"files/distance.matrix.per.gene.swift.txt"), header=T)
birds48filename=paste0(WD,"files/48birds_ortholog.list.chi.anna.cpe.hum.finch")
birds=read.table(birds48filename, header=T,
    colClasses=c("character","numeric","character","character",
      "character","character","character"))

birds.2=birds[birds$anna!="-",]
birds.3=birds.2[birds.2$swift!="-",]
birds.4=unique(birds.3)
birds.5=birds.4[,c("anna","swift")]
birds.5$swift=paste0("Parent=",birds.5$swift,";")
birds.5$anna=paste0("Parent=Aan_", birds.5$anna,";")
annaGenes=unique(gffAnna$V9)
birds.6=birds.5[birds.5$anna %in% annaGenes, ]
birds.6$swift.plain=unlist(strsplit(unlist(lapply(strsplit(birds.6$swift,"_"), function(x){x[[2]]})), ";"))
birds.6$anna.plain=unlist(strsplit(unlist(lapply(strsplit(birds.6$anna,"_"), function(x){x[[2]]})), ";"))
smallbird=birds.6[birds.6$anna.plain %in% intersect(birds.6$anna.plain,geneList),]
distancesAnna=distancesAnna[smallbird$anna.plain,]
distancesSwift=distancesSwift[smallbird$anna.plain,]
rownames(distancesAnna)=smallbird$anna
rownames(distancesSwift)=smallbird$swift
```

- Retrieved the coverage information per gene and filtered the coverage
matrices to match the **623** resulting genes.

```{R, eval=F}
samplesFilenameAnna=paste0(WD,"anna/files/samples.txt")
samplesFilenameSwift=paste0(WD,"swift/files/samples.txt")
sampleNamesAnna=unlist(read.table(samplesFilenameAnna, stringsAsFactors = F))
sampleNamesSwift=unlist(read.table(samplesFilenameSwift, stringsAsFactors = F))
coverageMatrixFileAnna=paste0(WD,"anna/files/coverage.matrix.per.gene.txt")
coverageMatrixFileSwift=paste0(WD,"swift/files/coverage.matrix.per.gene.txt")
coverageMatrixAnna=read.table(coverageMatrixFileAnna, header=T)/genesAnna$Size
coverageMatrixSwift=read.table(coverageMatrixFileSwift, header=T)/genesSwift$Size
rownames(coverageMatrixAnna)=genesAnna$Gene
rownames(coverageMatrixSwift)=genesSwift$Gene
#-------------------------------------------------------------------------------
cmswift=coverageMatrixSwift[smallbird$swift,]
cmanna=coverageMatrixAnna[smallbird$anna,]
cmanna=cbind(cmanna,AnnaBGI=rep(0,nrow(cmanna)), SwiftBGI=rep(0,nrow(cmanna)))
```

- Linear correlation was calculated after removing outliers in both coverage and distance
- What is shown in the plot below is the relation between depth of coverage and phylogenetic distance
per gene per sample. **623** genes were used. **48** Samples.

<ul class="nav nav-tabs">
<li class="active"><a href="#anna-cov-vs-dist-lm" data-toggle="tab">Anna - Coverage vs. distance (Corr)</a></li>
<li><a href="#swift-cov-vs-dist-lm" data-toggle="tab">Swift - Coverage vs. distance (Corr)</a></li>
</ul>

<div id="myTabContent" class="tab-content">
<div class="tab-pane fade active in" id="anna-cov-vs-dist-lm">

<div class="panel panel-default">
<div class="panel-body">
![](/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/img/phylo.distance.coverage.genes.png)

```{bash, echo=F}
cat /media/merly/Baymax/research/cph-visit/coverage-analysis/anna/files/lm.dist.cov.phylo.txt
```

![](/media/merly/Baymax/research/cph-visit/coverage-analysis/anna/img/phylo.distance.coverage.genes.lm.4.png)
</div>
</div>
</div>

<div class="tab-pane fade" id="swift-cov-vs-dist-lm">
<div class="panel panel-default">
<div class="panel-body">

![](/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/img/phylo.distance.coverage.genes.png)

```{bash, echo=F}
cat /media/merly/Baymax/research/cph-visit/coverage-analysis/swift/files/lm.dist.cov.phylo.txt
```
![](/media/merly/Baymax/research/cph-visit/coverage-analysis/swift/img/phylo.distance.coverage.genes.lm.4.png)
</div>
</div>
</div>
</div>

- P-values show that there might be a linear relation between these 2 variables




### Detailed - pairs per species

Now, the plots below show the relation between phylogenetic distance and coverage, of two (`2`)
samples from the Cocquettes, Brilliants, Mangoes and Hermits groups, following the ML tree
from the Hummingbirds paper (F1,A). These samples correspond to one with high coverage and one
with low coverage.


<div class="row">
<div class="col-lg-6">
<div class="bs-component">
![](/media/merly/Baymax/research/cph-visit/coverage-analysis/img/hummingbirds.paper.f1a.png)
</div>
</div>

<div class="col-lg-6">
<div class="bs-component">
![](/media/merly/Baymax/research/cph-visit/coverage-analysis/img/hummingbird.paper.fig1.names.png)
</div>
</div>
</div>


<ul class="nav nav-tabs">
<li class="active"><a href="#coquettes-brilliants" data-toggle="tab">Coquettes and Brilliants</a></li>
<li><a href="#mangoes-hermits" data-toggle="tab">Mangoes and Hermits</a></li>
</ul>

<div id="myTabContent" class="tab-content">
<div class="tab-pane fade active in" id="coquettes-brilliants">
<div class="panel panel-default">
<div class="panel-body">
![](/media/merly/Baymax/research/cph-visit/coverage-analysis/img/corr.high.low.coverage.phylodist.vs.cov.png)
</div>
</div>
</div>
<div class="tab-pane fade" id="mangoes-hermits">
<div class="panel panel-default">
<div class="panel-body">
![](/media/merly/Baymax/research/cph-visit/coverage-analysis/img/corr.high.low.coverage.phylodist.vs.cov.p2.png)
</div>
</div>
</div>
</div>


-------------------------------------------------------------------------------

**References**

<div id="Bleiweiss">
- [1]: Bleiweiss R, Kirsch JAW, Matheus JC (1994) *DNA-DNA Hybridization Evidence for Sub-family Structure among Hummingbirds*. Auk 111(1):8â19.
[DOI: 10.2307/4088500](http://www.jstor.org/stable/4088500)
</div>
<div id="McGuire">
- [2]: McGuire JA, et al. (2014) *Molecular phylogenetics and the diversification of hummingbirds*. Curr Biol 24(8):910â6.
[DOI: 10.1016/j.cub.2014.03.016](http://www.sciencedirect.com/science/article/pii/S0960982214002759)
</div>
<div id="raxml">
- [3]: Stamatakis A (2014) *RAxML version 8: a tool for phylogenetic analysis and post-analysis of large phylogenies.* Bioinformatics 30(9):1312â1313.
[DOI: 10.1093/bioinformatics/btu033](https://doi.org/10.1093/bioinformatics/btu033)
</div>
<div id="astral">
- [4]: Mirarab S, et al. (2014) *ASTRAL: genome-scale coalescent-based species tree estimation.* Bioinformatics 30(17):i541â8.
[DOI: 10.1093/bioinformatics/btu462](https://doi.org/10.1093/bioinformatics/btu462)
</div>
<div id="astralii">
- [5]: Mirarab S, Warnow T (2015) *ASTRAL-II: coalescent-based species tree estimation with many hundreds of taxa and thousands of genes.* Bioinformatics 31(12):i44â52.
[DOI: 10.1093/bioinformatics/btv234](https://doi.org/10.1093/bioinformatics/btv234)
</div>
<div id="jarvis">
- [6]: Jarvis ED, et al. (2014) *Whole Genome Analyses Resolve the Early Branches in the Tree of Life of Modern Birds.* Science (80- ) 346(6215):1320â1331.
[DOI: 10.1126/science.1253451](http://science.sciencemag.org/content/346/6215/1320)
</div>
<div id="phangorn">
- [7]: Klaus Peter Schliep (2011) *phangorn: phylogenetic analysis in R.* Bioinformatics 27 (4): 592-593.
[DOI: 10.1093/bioinformatics/btq706](https://doi.org/10.1093/bioinformatics/btq706)
</div>
<div id="braggs">
- [8]: Bragg, JG., Potter, S., Bi. K. and Moritz, C. (2016) *Exon capture phylogenomics: efficacy across scales of divergence* Molecular Ecology Resources  16, 1059â1068.
[DOI: 10.1111/1755-0998.12449](http://onlinelibrary.wiley.com/doi/10.1111/1755-0998.12449/pdf)
</div>

<div id="bedtools">
- [9] Aaron R. Quinlan  Ira M. Hall (2010) *BEDTools: a flexible suite of utilities for comparing genomic features* Bioinformatics  26 (6): 841-842.
[DOI: 10.1093/bioinformatics/btq033](https://doi.org/10.1093/bioinformatics/btq033)
</div>

<div id="angsd">
- [10] Korneliussen, Thorfinn S. and Albrechtsen, Anders and Nielsen, Rasmus (2014) *ANGSD: Analysis of Next Generation Sequencing Data* BMC Bioinformatics 15:356.
[DOI: 10.1186/s12859-014-0356-4](http://www.biomedcentral.com/1471-2105/15/356/abstract)
</div>
